<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>All-in-one-minimize</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Set the worker URL for PDF.js - required.
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // --- OPTIMIZATION: Configurable Quality Scales ---
    // Lowest scale for fastest, lowest resolution rendering.
    const LOW_QUALITY_SCALE = 1.0; 
    // Medium scale for good on-screen quality and FASTEST save speed.
    const DEFAULT_QUALITY_SCALE = 2.5; 
    // Highest practical scale for smooth live screen rendering or better save speed.
    const SCREEN_MAX_QUALITY_SCALE = 4.0; 
    // ULTIMATE scale for final PDF/Image saving and printing. (Highest Quality)
    const FINAL_SAVE_QUALITY_SCALE = 6.0; 

    // Global variable to track the current quality scale for screen rendering and browser printing
    let CURRENT_RENDER_SCALE = 4.0; // Changed default to SCREEN_MAX_QUALITY_SCALE (4.0)

    // Global map to store loaded PDF documents by a unique ID, to avoid reloading
    const loadedPDFs = new Map();
    let nextPdfId = 1;
  </script>

  <style>
    :root { 
        --paper-padding-mm: 10; 
        --toggle-controls-bg: red;    
        --toggle-controls-border: #388E3C;
        --toggle-controls-icon-color: white; 
    }

    body {
      background: url('https://mrdesigner-create.github.io/photoes/Beautiful-Rose.jpg') center/cover no-repeat fixed !important;
      padding: 20px;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
      margin: 0;
      transition: background 0.6s;
    }
    body.bg-gradient { background: linear-gradient(to bottom right, skyblue, #ff4b4b) !important; }

    /* MODIFIED: Added position:relative and z-index: 1 to ensure paper is below the control panel's z-index:10001 */
    #page-wrapper { 
        display:flex; 
        flex-direction:column; 
        align-items:flex-start; 
        width:100%; 
        position: relative; 
        z-index: 1;
    }

    .a4-page { width:210mm; min-height:297mm; }
    .a5-page { width:148mm; min-height:210mm; }
    .a6-page { width:105mm; min-height:148mm; }
    .us-letter-page { width:8.5in; min-height:11in; }
    .a4-page.landscape { width:297mm; min-height:210mm; }
    .a5-page.landscape { width:210mm; min-height:148mm; }
    .a6-page.landscape { width:148mm; min-height:105mm; }
    .us-letter-page.landscape { width:11in; min-height:8.5in; }

    .paper {
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      background:#fff;
      margin-bottom:20px;
      padding:0; 
      box-sizing:border-box;
      position: relative;
    }
    .a4-page.hidden, .a5-page.hidden, .a6-page.hidden, .us-letter-page.hidden { display:none !important; }

    .grid-container { display: grid; width: 100%; height: 100%; }

    .box {
      border: 1px dashed #ccc; 
      display: flex; 
      justify-content: center; 
      align-items: center;
      font-size: 10px;
      color: #999;
      box-sizing: border-box;
      cursor: pointer;
      transition: border-color 0.2s;
      overflow: hidden;
      padding: 0;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      min-width: 0;
      min-height: 0;
      position: relative;
    }
    .box:hover { border-color: #3498db; }
    .box img, .box canvas { width: 100%; height: 100%; object-fit: contain; display: block; margin: auto; }
    .box canvas { max-width: 100%; max-height: 100%; display: block; }

    .box.empty-state.color-a { background-color: #f0f8ff !important; }
    .box.empty-state.color-b { background-color: #fff8e1 !important; }
    .box.empty-state.color-c { background-color: #e1f3e8 !important; }
    .box.empty-state.color-d { background-color: #fbebf7 !important; }

    .box.filled-state { background-color: #e8f5e9 !important; }

    /* MODIFIED: Increased z-index for controls and control panel container to ensure it is on top */
    .controls { padding:10px; background:red; border:1px solid #95a5a6; z-index:10002; max-width:360px;
      text-align:center; max-height:80vh; overflow-y:auto; overflow-x:hidden;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.25), inset -2px -2px 5px rgba(255,255,255,0.8);
    }
    .controls-panel-container { position:fixed; top:20px; right:20px; transition:right 1.10s; z-index:10001; }
    .controls-panel-container.hidden { right:-382px; }

    #toggle-controls-btn { position:absolute; top:0; left:-54px; height:68px; width:59px; border:1px solid var(--toggle-controls-border); border-right:10px; background:var(--toggle-controls-bg); color: var(--toggle-controls-icon-color); display:flex; align-items:center; justify-content:center; border-radius:22px 0 0 20px; cursor:pointer; box-shadow:-10px 0 8px rgba(0,0,0,0.1); font-size: 24px; }

    #toggle-bg-btn { position:fixed; top:20px; left:20px; background:yellow; border:1px solid red; box-shadow: 0 8px 8px rgba(0,0,0,0.3); padding:8px 8px; cursor:pointer; z-index:10001; }

    .controls button, .controls select, .controls input[type="number"] { padding:10px 12px; margin:6px 0; border:1px solid lightgray; font-size:14px; width:100%; box-sizing:border-box; background-color: white; }
    .controls h4 { margin:10px 0 6px; }
    .hidden-input { display:none; }
    .input-group { display: flex; gap: 5px; }
    .input-group input { width: 50%; }
    .input-group-four { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }

    .input-group-radio {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        background: #eee !important;
        border: 1px solid #aaa !important;
        padding: 5px;
        border-radius: 4px;
    }
    .input-group-radio label {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 4px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 10px;
        cursor: pointer;
        background-color: LightYellow !important;
        color: #333 !important;
        transition: background-color 0.2s;
    }
    .input-group-radio label:hover { background-color: gold !important; }
    .input-group-radio input[type="radio"] { margin-right: 2px; width: auto; display: none; }
    .input-group-radio input[type="radio"]:checked + span {
        font-weight: bold;
        color: white !important;
        background-color: LimeGreen !important;
        border-radius: 4px;
        padding: 4px;
    }
    .input-group-radio label span { pointer-events: none; }

    #context-menu {
        position: fixed;
        background: #fff;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        list-style: none;
        padding: 0;
        margin: 0;
        z-index: 10002;
        display: none;
        min-width: 150px;
    }
    #context-menu li { padding: 8px 12px; cursor: pointer; font-size: 14px; }
    #context-menu li:hover { background: #f0f0f0; }

    #edit-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 10003; }
    .modal-content { background: #333; color: #fff; padding: 25px; border-radius: 12px; width: 95%; max-width: 900px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6); max-height: 90vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease-out; }
    #edit-modal.active .modal-content { transform: scale(1); }
    .modal-content h3 { margin-top: 0; border-bottom: 2px solid #555; padding-bottom: 10px; color: #f39c12; }
    .modal-main-area { display: flex; gap: 20px; }
    .modal-preview-container { flex: 3; min-width: 60%; }
    .modal-sidebar { flex: 1; min-width: 25%; background: #444; padding: 15px; border-radius: 6px; }
    .modal-sidebar label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; color: #ccc;}
    .modal-sidebar input[type="number"] { padding: 8px; width: 100%; box-sizing: border-box; border: 1px solid #666; background: #222; color: #fff; border-radius: 4px; }
    #modal-preview { border: 2px solid #666; min-height: 400px; display: flex; justify-content: center; align-items: center; margin-bottom: 15px; background-color: #222; overflow: hidden; border-radius: 4px; }
    #modal-preview img, #modal-preview canvas { max-width: 100%; max-height: 100%; object-fit: contain; display:block; }

    .modal-actions button { margin: 5px 0; padding: 10px 15px; font-size: 15px; cursor: pointer; width: 100%; border: none; border-radius: 4px; color: #fff; transition: background-color 0.2s; }
    .modal-actions .btn-primary { background-color: #3498db; }
    .modal-actions .btn-replace { background-color: #2ecc71; }
    .modal-actions .btn-crop { background-color: #e67e22; }
    .modal-actions .btn-delete { background-color: #e74c3c; }
    .modal-actions .btn-close { background-color: #555; margin-top: 15px;}
    .modal-actions .btn-adjust { background-color: #f39c12; }

    @media print {
      .controls-panel-container, #toggle-controls-btn, #toggle-bg-btn, #togglePaperBtn, #add-page-btn, #context-menu, #edit-modal, #save-as-type-select, #save-sheets-btn, #quality-select-container, #save-quality-select-container { display:none; }
      body { padding:0; background-color:white; }
      .paper { width:auto !important; min-height:auto !important; margin:0; padding:0; box-shadow:none; page-break-after:always; }
      .a4-page.landscape { -webkit-print-color-adjust: exact; size: A4 landscape !important; }
      .us-letter-page.landscape { -webkit-print-color-adjust: exact; size: letter landscape !important; }
      /* Print will use the ULTIMATE scale (6.0x) for capture via browser's rendering of canvas elements */
      .box { border: none !important; background-color: white !important; }
      .box span { display: none; }
      .box canvas { width: 100%; height: 100%; display: block; }
      @page { margin:0; }
    }
    
    /* ADDED: Style to hide the filename overlay during save capture */
    #page-wrapper.hide-overlays .file-name-overlay {
        display: none !important;
    }

    #togglePaperBtn { background-color: yellow !important; color: black !important; border-color: black !important; font-weight: bold !important; border-width: 2px !important; }
    #paper-size-select { background-color: purple !important; color: white !important; border-color: yellow !important; font-weight: bold !important; border-width: 2px !important; -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important; }
    #print-btn { background-color: crimson !important; color: white !important; border-color: #3498db !important; font-weight: bold !important; border-width: 2px !important; }
    #add-page-btn { background-color: orangered !important; color: white !important; border-color: #333 !important; font-weight: bold !important; border-width: 2px !important; }
    #multi-upload-btn { background-color: deepskyblue !important; color: white !important; border-color: navy !important; font-weight: bold !important; border-width: 2px !important; }
    #save-sheets-btn { background-color: darkgreen !important; color: white !important; border-color: #333 !important; font-weight: bold !important; border-width: 2px !important; transition: background-color 0.15s, opacity 0.15s; }
    #save-as-type-select { background-color: LightCoral !important; color: white !important; border-color: #333 !important; font-weight: bold !important; border-width: 2px !important; -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important;}
    #quality-select, #save-quality-select { background-color: LightBlue !important; color: #333 !important; border-color: navy !important; font-weight: bold !important; border-width: 2px !important; -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important;}

    .controls input[type="number"] { background-color: LightCyan !important; color: #333 !important; border: 2px solid DarkCyan !important; }

  </style>
</head>
<body class="bg-image">

  <button id="toggle-bg-btn">üíß Show/Hide</button>

  <div id="controls-panel-container" class="controls-panel-container hidden">
    <div class="controls">
      <button id="toggle-controls-btn">‚óÄ</button>

      <div id="controls-content">
        <button id="togglePaperBtn">Show Screen Paper</button>
        <button id="add-page-btn" onclick="addNewPage()">‚ûï Add Empty Page (1 Divisions)</button> 
        
        <div id="quality-select-container">
            <h4>‚öôÔ∏è Screen/Preview Quality (Speed):</h4> 
            <select id="quality-select">
                <option value="1.0">Fastest (Low Quality - 1.0x)</option>
                <option value="2.5">Better (Good Quality - 2.5x)</option>
                <option value="4.0" selected>Highest (Max Speed/Quality Balance - 4.0x)</option>
                <option value="6.0">Ultimate Quality (Slowest Re-render - 6.0x)</option>
            </select>
            <p style="font-size:.85em; margin-top:10px;">Note: Changing this will re-render everything.</p>
        </div>

        <h4>‚ûó Division Layout:</h4>
        <div id="division-controls" class="input-group-radio"> 
            <label>
                <input type="radio" name="pageDivision" value="1" checked> <span>Divide 1 (1x1)</span>
            </label>
            <label>
                <input type="radio" name="pageDivision" value="2">
                <span>Divide 2 (1x2)</span>
            </label>
            <label>
                <input type="radio" name="pageDivision" value="4">
                <span>Divide 4 (2x2)</span>
            </label>
        </div>

        <h4>üß≠ Orientation:</h4>
        <div id="orientation-controls" class="input-group-radio"> <label>
                <input type="radio" name="paperOrientation" value="portrait" checked>
                <span>Portrait</span>
            </label>
            <label>
                <input type="radio" name="paperOrientation" value="landscape">
                <span>Landscape</span>
            </label>
        </div>

        <h4>üìÑ Paper Size:</h4>
        <select id="paper-size-select">
          <option value="a4">A4 (210 x 297 mm)</option>
          <option value="us-letter">US Letter (8.5 x 11 in)</option>
          <option value="a5">A5 (148 x 210 mm)</option>
          <option value="a6">A6 (105 x 148 mm)</option>
        </select>

        <h4>üìê Custom Margins (mm):</h4>
        <div class="input-group-four">
            <input type="number" id="margin-top" min="0" value="0" placeholder="Top"> <input type="number" id="margin-bottom" min="0" value="0" placeholder="Bottom"> <input type="number" id="margin-left" min="0" value="0" placeholder="Left"> <input type="number" id="margin-right" min="0" value="0" placeholder="Right"> </div>

        <h4>üìè Division Size (mm):</h4>
        <div class="input-group">
            <input type="number" id="box-width" min="1" value="210" placeholder="Width (mm)" data-calculated="true"> <input type="number" id="box-height" min="1" value="297" placeholder="Height (mm)" data-calculated="true"> </div>

        <h4>‚¨áÔ∏è Gap Spacing (mm):</h4>
        <div class="input-group">
            <input type="number" id="row-gap-input" min="0" value="5" placeholder="Row Gap (Vertical)">
            <input type="number" id="col-gap-input" min="0" value="5" placeholder="Column Gap (Horizontal)">
        </div>

        <h4>‚¨ÜÔ∏è Upload Mode:</h4>
        <div id="upload-mode-controls" class="input-group-radio">
            <label data-mode="serial" data-division="1,2,4">
                <input type="radio" name="uploadMode" value="serial" checked>
                <span>Serial Wise (1, 2, 3...)</span>
            </label>
            <label data-mode="interleaved-A" data-division="2">
                <input type="radio" name="uploadMode" value="interleaved-A">
                <span>Interleaved (1, 3, 2, 4)</span>
            </label>
            <label data-mode="interleaved-standard" data-division="4">
                <input type="radio" name="uploadMode" value="interleaved-standard">
                <span>Standard Interleaved (1, 5, 2, 6)</span>
            </label>
             <label data-mode="interleaved-custom" data-division="4">
                <input type="radio" name="uploadMode" value="interleaved-custom">
                <span>Custom Interleaved (1, 6, 2, 5)</span>
            </label>
        </div>

        <h4>üì§ Upload Documents (PDF/DOC ready):</h4>
        <input id="multi-file-input" class="hidden-input" type="file" accept="image/*, .pdf" multiple>
        <button id="multi-upload-btn">‚ûï Choose Files (Images/PDF)</button>

        <h4>üíæ Save Sheets As Type:</h4> 
        <select id="save-as-type-select">
            <option value="pdf" selected>PDF Document (*.pdf)</option> 
            <option value="png">PNG Image (*.png)</option>
            <option value="jpg">JPEG Image (*.jpg)</option>
            <option value="doc">DOC Document (*.doc)</option>
            <option value="docx">DOCX Document (*.docx)</option>
        </select>

        <div id="save-quality-select-container">
            <h4>üöÄ Save Quality (Affects Speed):</h4> 
            <select id="save-quality-select">
                <option value="6.0">Ultimate Quality (6.0x - Slow)</option>
                <option value="4.0">High Quality (4.0x - Medium Speed)</option>
                <option value="2.5" selected>Fast Quality (2.5x - Fastest)</option> 
            </select>
        </div>

        <button id="save-sheets-btn" onclick="saveSheetsAsFile()">üíæ Start Save(2.5x) </button>  
        <p style="font-size:.85em; margin-top:10px;">*The speed is fast now. PDF save quality is limited by the **Screen/Preview Quality** setting above.*</p>

        <button id="print-btn" onclick="window.print()">üñ®Ô∏è Print All Sheets</button>
      </div>
    </div>
  </div>

  <div id="page-wrapper"></div>

  <ul id="context-menu">
      <li id="context-adjust" onclick="handleContextMenuAction('üí° Photo Adjust')">üí° Photo Adjust</li>
      <li id="context-replace" onclick="handleContextMenuAction('üîÑ Replace File')">üîÑ Replace File</li>
      <li id="context-crop" onclick="handleContextMenuAction('‚úÇÔ∏è Crop Option')">‚úÇÔ∏è Crop Option</li>
      <li onclick="deleteFile()">üóëÔ∏è Delete File</li>
  </ul>
  
  <div id="edit-modal">
      <div class="modal-content">
          <h3 id="modal-title">File Editor</h3>
          
          <div class="modal-main-area">
              <div class="modal-preview-container">
                  <div id="modal-preview"></div>

                  <div id="pdf-nav-controls" style="display:none; text-align:center; margin-top:8px;">
                    <button id="pdf-prev-btn">‚óÄ Prev</button>
                    <span id="pdf-page-indicator" style="margin:0 10px;">Page 1 / 1</span>
                    <button id="pdf-next-btn">Next ‚ñ∂</button>
                  </div>

                  <p style="font-size: 0.9em;">
                    **File:** <span id="modal-file-name">N/A</span> 
                    <br>
                    **Type:** <span id="modal-file-type">N/A</span>
                  </p>
              </div>

              <div class="modal-sidebar">
                  <p style="font-weight: bold; color: #ccc; margin-top: 0;">Available Actions:</p>
                  
                  <div id="adjust-controls" style="display:none;">
                      <label for="brightness-input">Brightness (%)</label>
                      <input type="number" id="brightness-input" min="50" max="200" value="100">
                      
                      <label for="contrast-input">Contrast (%)</label>
                      <input type="number" id="contrast-input" min="50" max="200" value="100">
                      
                      <button class="btn-adjust" onclick="applyImageAdjustments()">‚úÖ Apply Adjustments</button>
                      <button class="btn-adjust" onclick="resetImageAdjustments()">üîÑ Reset</button>
                      <p style="font-size: 0.7em; margin-top: 5px; color: #aaa;">(Only affects images, not PDFs.)</p>
                  </div>
                  
                  <div id="crop-controls" style="display:none;">
                      <label for="crop-width-input">Crop Width (px)</label>
                      <input type="number" id="crop-width-input" min="1" value="300">
                      
                      <label for="crop-height-input">Crop Height (px)</label>
                      <input type="number" id="crop-height-input" min="1" value="200">
                      
                      <button class="btn-crop" onclick="applyCrop()">‚úÖ Apply Crop</button>
                      <p style="font-size: 0.7em; margin-top: 5px; color: #aaa;">(Cropping is simulated by changing the box size.)</p>
                  </div>
                  
                  <div class="modal-actions">
                      <button class="btn-primary" id="modal-adjust-btn" onclick="openEditingModal('üí° Photo Adjust')">üí° Photo Adjust</button>
                      <button class="btn-replace" onclick="document.getElementById('modal-replace-input').click()">üîÑ Replace File</button>
                      <button class="btn-crop" id="modal-crop-btn" onclick="openEditingModal('‚úÇÔ∏è Crop Option')">‚úÇÔ∏è Crop Option</button>
                      <button class="btn-delete" onclick="deleteFileFromModal()">üóëÔ∏è Delete File</button>
                      
                      <input type="file" id="modal-replace-input" class="hidden-input" accept="image/*, .doc,.docx, .pdf" onchange="handleModalFileReplacement(event)">

                      <button class="btn-close" onclick="closeModal()">‚ùå Close Editor</button>
                  </div>
              </div>
          </div>
      </div>
  </div>

<script>
/* ---------- JS: Core Functions ---------- */

/* ---------- Constants & Globals ---------- */
const PAPER_SIZES = { 'a4': { w:210, h:297 }, 'us-letter': { w:215.9, h:279.4 }, 'a5': { w:148, h:210 }, 'a6': { w:105, h:148 } };
const DIVISION_LAYOUTS = { '1': { cols: 1, rows: 1, boxesPerPage: 1 }, '2': { cols: 1, rows: 2, boxesPerPage: 2 }, '4': { cols: 2, rows: 2, boxesPerPage: 4 } };

let marginTop = 0, marginBottom = 0, marginLeft = 0, marginRight = 0; 
let currentPaperSize = 'a4', currentBoxWidth = 0, currentBoxHeight = 0, currentColGap = 0, currentRowGap = 0;
let isCustomSize = false;
let currentDivision = '1'; 
let currentOrientation = 'portrait';
let currentLayout = DIVISION_LAYOUTS['1']; 
let currentPageIndex = 0, nextDivisionNumber = 1;
let activeBoxElement = null;
let uploadMode = 'serial', currentInterleavedFileIndex = 0;
let boxFileMap = new Map();
let currentModalAction = '';

let modalPdfObj = null, modalPdfPageNum = 1, modalPdfTotalPages = 1, modalPdfCurrentBoxId = null;

function isPdfPageEntry(obj) {
    return obj && obj.kind === 'pdfpage' && typeof obj.pdfId === 'number' && typeof obj.pageNumber === 'number'; // Check for pdfId instead of pdf object
}

/* ---------- Context Menu & Modal handlers (kept as original) ---------- */
function hideContextMenu() {
    document.getElementById('context-menu').style.display = 'none';
    document.removeEventListener('click', hideContextMenuOnOutsideClick);
}
function hideContextMenuOnOutsideClick(e) {
    const menu = document.getElementById('context-menu');
    if (!menu.contains(e.target) && e.target !== activeBoxElement && !menu.contains(e.target)) {
        hideContextMenu();
    }
}
function showContextMenu(boxElement, x, y) {
    hideContextMenu();
    activeBoxElement = boxElement;
    const entry = boxFileMap.get(parseInt(boxElement.id.split('-')[2]));
    const isPDF = isPdfPageEntry(entry);
    document.getElementById('context-adjust').style.display = isPDF ? 'none' : 'list-item';
    document.getElementById('context-crop').style.display = isPDF ? 'none' : 'list-item';
    const contextMenu = document.getElementById('context-menu');
    contextMenu.style.left = `${Math.min(x, window.innerWidth - 170)}px`;
    contextMenu.style.top = `${Math.min(y, window.innerHeight - contextMenu.offsetHeight - 10)}px`;
    contextMenu.style.display = 'block';
    setTimeout(() => { document.addEventListener('click', hideContextMenuOnOutsideClick); }, 10);
}
window.handleContextMenuAction = function(action) {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) {
        if (action !== 'üóëÔ∏è Delete File') {
            alert("No file in this box to edit.");
            hideContextMenu();
            return;
        }
    }
    if (action === 'üóëÔ∏è Delete File') deleteFile();
    else openEditingModal(action);
}

function openEditingModal(action) {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) {
        alert("No file found in this box to edit. Upload a file first.");
        hideContextMenu();
        return;
    }
    const divisionNumber = parseInt(activeBoxElement.id.split('-')[2]);
    const entry = boxFileMap.get(divisionNumber);
    currentModalAction = action;
    const isPDF = isPdfPageEntry(entry);

    document.getElementById('adjust-controls').style.display = (!isPDF && action === 'üí° Photo Adjust') ? 'block' : 'none';
    document.getElementById('crop-controls').style.display = (!isPDF && action === '‚úÇÔ∏è Crop Option') ? 'block' : 'none';

    document.getElementById('modal-adjust-btn').disabled = isPDF;
    document.getElementById('modal-crop-btn').disabled = isPDF;
    document.getElementById('modal-adjust-btn').style.opacity = isPDF ? 0.5 : 1;
    document.getElementById('modal-crop-btn').style.opacity = isPDF ? 0.5 : 1;

    document.getElementById('modal-title').textContent = `${action} View for Box ${divisionNumber}`;
    document.getElementById('modal-file-name').textContent = activeBoxElement.dataset.fileName;
    document.getElementById('modal-file-type').textContent = isPDF ? 'application/pdf (page preview)' : (entry && entry.type ? entry.type : 'Unknown/Placeholder');

    const preview = document.getElementById('modal-preview');
    preview.innerHTML = '';

    modalPdfObj = null; modalPdfPageNum = 1; modalPdfTotalPages = 1; modalPdfCurrentBoxId = null;
    document.getElementById('pdf-nav-controls').style.display = 'none';

    if (isPdfPageEntry(entry)) {
        // Retrieve PDF object from the global map
        const pdfDoc = loadedPDFs.get(entry.pdfId);
        if (pdfDoc) {
            modalPdfObj = pdfDoc;
            modalPdfTotalPages = modalPdfObj.numPages;
            modalPdfPageNum = entry.pageNumber;
            modalPdfCurrentBoxId = divisionNumber;
            document.getElementById('pdf-nav-controls').style.display = 'block';
            document.getElementById('pdf-page-indicator').textContent = `Page ${modalPdfPageNum} / ${modalPdfTotalPages}`;
            // Use CURRENT_RENDER_SCALE for modal preview
            renderPdfPageInModal(modalPdfObj, modalPdfPageNum, preview);
        } else {
             preview.innerHTML = `<span style="color:#ccc">Error: PDF document not found in cache.</span>`;
        }
    } else if (entry && entry.type && entry.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function(ev) {
            const img = document.createElement('img');
            img.src = ev.target.result;
            img.alt = activeBoxElement.dataset.fileName;
            img.style.filter = activeBoxElement.dataset.filter || 'none';
            preview.appendChild(img);

            const currentBrightness = activeBoxElement.dataset.brightness || '100';
            const currentContrast = activeBoxElement.dataset.contrast || '100';
            document.getElementById('brightness-input').value = currentBrightness;
            document.getElementById('contrast-input').value = currentContrast;

            const currentCropWidth = activeBoxElement.dataset.cropWidth || activeBoxElement.clientWidth;
            const currentCropHeight = activeBoxElement.dataset.cropHeight || activeBoxElement.clientHeight;
            document.getElementById('crop-width-input').value = currentCropWidth;
            document.getElementById('crop-height-input').value = currentCropHeight;
            updateModalPreviewImageCrop();
        };
        reader.readAsDataURL(entry);
    } else {
        preview.innerHTML = `<span style="color:#ccc">Cannot render preview for this item.</span>`;
    }

    document.getElementById('edit-modal').style.display = 'flex';
    document.getElementById('edit-modal').classList.add('active');
    hideContextMenu();
}

/* ---------- Render PDF page in modal ---------- */
function renderPdfPageInModal(pdf, pageNum, previewContainer) {
    previewContainer.innerHTML = '';
    // Add loading indicator
    previewContainer.innerHTML = '<span style="color:#f39c12; font-size: 1.2em;">Loading PDF Page...</span>';
    
    pdf.getPage(pageNum).then(page => {
        const previewContainerWidth = Math.min(previewContainer.clientWidth || 800, 900);
        const pageViewport1 = page.getViewport({ scale: 1 });

        const baseScaleToFit = previewContainerWidth / pageViewport1.width;
        // OPTIMIZATION: Use CURRENT_RENDER_SCALE for modal rendering
        const finalScale = baseScaleToFit * CURRENT_RENDER_SCALE;
        const viewport = page.getViewport({ scale: finalScale });

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);
        canvas.style.width = '100%';
        canvas.style.height = '100%';

        previewContainer.innerHTML = ''; // Clear loading indicator

        const renderContext = { canvasContext: ctx, viewport: viewport };
        page.render(renderContext).promise.then(() => {
            previewContainer.appendChild(canvas);
            document.getElementById('pdf-page-indicator').textContent = `Page ${modalPdfPageNum} / ${modalPdfTotalPages}`;
        }).catch(err => {
            previewContainer.innerHTML = `<div style="color:#ccc">Error rendering PDF page: ${err.message}</div>`;
        });
    }).catch(err => {
        previewContainer.innerHTML = `<div style="color:#ccc">Error loading PDF page: ${err.message}</div>`;
    });
}

document.getElementById('pdf-prev-btn')?.addEventListener('click', () => {
    if (!modalPdfObj) return;
    if (modalPdfPageNum > 1) {
        modalPdfPageNum--;
        // Update the boxFileMap entry for the currently open box
        if (modalPdfCurrentBoxId && isPdfPageEntry(boxFileMap.get(modalPdfCurrentBoxId))) {
            const entry = boxFileMap.get(modalPdfCurrentBoxId);
            entry.pageNumber = modalPdfPageNum;
            boxFileMap.set(modalPdfCurrentBoxId, entry);
            renderFileInBox(document.getElementById(`box-div-${modalPdfCurrentBoxId}`), entry); // Re-render the box on the sheet
        }
        renderPdfPageInModal(modalPdfObj, modalPdfPageNum, document.getElementById('modal-preview'));
    }
});
document.getElementById('pdf-next-btn')?.addEventListener('click', () => {
    if (!modalPdfObj) return;
    if (modalPdfPageNum < modalPdfTotalPages) {
        modalPdfPageNum++;
        // Update the boxFileMap entry for the currently open box
        if (modalPdfCurrentBoxId && isPdfPageEntry(boxFileMap.get(modalPdfCurrentBoxId))) {
            const entry = boxFileMap.get(modalPdfCurrentBoxId);
            entry.pageNumber = modalPdfPageNum;
            boxFileMap.set(modalPdfCurrentBoxId, entry);
            renderFileInBox(document.getElementById(`box-div-${modalPdfCurrentBoxId}`), entry); // Re-render the box on the sheet
        }
        renderPdfPageInModal(modalPdfObj, modalPdfPageNum, document.getElementById('modal-preview'));
    }
});

/* ---------- Image adjustment helpers (kept as original) ---------- */
function updateModalPreviewImageFilter() {
    const preview = document.getElementById('modal-preview');
    const img = preview.querySelector('img');
    if (img) {
        const brightness = document.getElementById('brightness-input').value;
        const contrast = document.getElementById('contrast-input').value;
        const filterStyle = `brightness(${brightness}%) contrast(${contrast}%)`;
        img.style.filter = filterStyle;
    }
}
function updateModalPreviewImageCrop() {
    const preview = document.getElementById('modal-preview');
    const width = Number(document.getElementById('crop-width-input').value);
    const height = Number(document.getElementById('crop-height-input').value);
    preview.style.width = 'auto';
    preview.style.height = 'auto';
    preview.style.maxWidth = '100%';
    preview.style.maxHeight = '100%';
    const img = preview.querySelector('img');
    if (img) {
        // Simple visual crop simulation: set the container size
        // This is primarily for visual feedback in the modal, not the final crop
        // The final crop is applied by changing the box size on the sheet.
        const parentRect = preview.getBoundingClientRect();
        const ratioW = parentRect.width / width;
        const ratioH = parentRect.height / height;
        const ratio = Math.min(ratioW, ratioH);
        
        preview.style.width = `${width * ratio}px`;
        preview.style.height = `${height * ratio}px`;
    }
}
window.applyImageAdjustments = function() {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) return;
    const brightness = document.getElementById('brightness-input').value;
    const contrast = document.getElementById('contrast-input').value;
    const filterStyle = `brightness(${brightness}%) contrast(${contrast}%)`;
    
    activeBoxElement.dataset.brightness = brightness;
    activeBoxElement.dataset.contrast = contrast;
    activeBoxElement.dataset.filter = filterStyle;
    activeBoxElement.style.filter = filterStyle;
    
    closeModal();
}
window.resetImageAdjustments = function() {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) return;
    document.getElementById('brightness-input').value = 100;
    document.getElementById('contrast-input').value = 100;
    
    activeBoxElement.dataset.brightness = 100;
    activeBoxElement.dataset.contrast = 100;
    activeBoxElement.dataset.filter = 'none';
    activeBoxElement.style.filter = 'none';
    
    updateModalPreviewImageFilter();
}
window.applyCrop = function() {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) return;
    const cropWidth = document.getElementById('crop-width-input').value;
    const cropHeight = document.getElementById('crop-height-input').value;
    
    activeBoxElement.style.width = `${cropWidth}px`;
    activeBoxElement.style.height = `${cropHeight}px`;
    activeBoxElement.dataset.cropWidth = cropWidth;
    activeBoxElement.dataset.cropHeight = cropHeight;
    
    closeModal();
}
window.closeModal = function() {
    document.getElementById('edit-modal').classList.remove('active');
    const preview = document.getElementById('modal-preview');
    preview.style.width = 'auto';
    preview.style.height = 'auto';
    setTimeout(() => { 
        document.getElementById('edit-modal').style.display = 'none'; 
        activeBoxElement = null; 
        currentModalAction = ''; 
        modalPdfObj = null; 
        modalPdfPageNum = 1; 
        modalPdfTotalPages = 1; 
        modalPdfCurrentBoxId = null; 
    }, 300);
}

/* ---------- Replace, delete & render functions (kept as original, slight defensive fixes) ---------- */
function handleModalFileReplacement(e) {
    const file = e.target.files[0];
    if (!file || !activeBoxElement) return;

    const divisionNumber = parseInt(activeBoxElement.id.split('-')[2]);

    if (file.type === 'application/pdf') {
        // Handle PDF replacement with an alert to confirm the action
        if (confirm(`Replacing a single box with a PDF will fill subsequent boxes starting at Box ${divisionNumber}. Continue?`)) {
            placePdfFileStartingAtBox(file, divisionNumber);
            e.target.value = null;
            closeModal();
        } else {
            e.target.value = null;
        }
        return;
    }

    boxFileMap.set(divisionNumber, file);
    activeBoxElement.dataset.fileName = file.name;
    renderFileInBox(activeBoxElement, file).then(() => {
        openEditingModal('üîÑ Replace File');
        e.target.value = null;
    }).catch(() => {
        boxFileMap.delete(divisionNumber);
        delete activeBoxElement.dataset.fileName;
        alert(`Failed to replace file with ${file.name}.`);
        closeModal();
    });
}
window.deleteFileFromModal = function() {
    if (!activeBoxElement) return;
    deleteFileFromBox(activeBoxElement);
    closeModal();
}

function deleteFile() {
    if (!activeBoxElement) return;
    deleteFileFromBox(activeBoxElement);
    hideContextMenu();
}

function deleteFileFromBox(boxElement) {
    const divisionNumber = parseInt(boxElement.id.split('-')[2]);
    if(isPdfPageEntry(boxFileMap.get(divisionNumber))){
        // Clear all pdf page entries associated with this PDF ID
        const pdfIdToDelete = boxFileMap.get(divisionNumber).pdfId;
        loadedPDFs.delete(pdfIdToDelete);

        for (let i = divisionNumber; i < nextDivisionNumber; i++){
            const box = document.getElementById(`box-div-${i}`);
            const entry = boxFileMap.get(i);
            if(entry && isPdfPageEntry(entry) && entry.pdfId === pdfIdToDelete){
                 // Clear the box content and data
                boxFileMap.delete(i);
                delete box.dataset.fileName;
                box.innerHTML = `<span>Page ${i}</span>`;
                box.classList.add('empty-state');
                box.classList.remove('filled-state');
                box.style.filter = 'none';
                box.style.backgroundImage = 'none';
            }
        }
    } else {
        boxFileMap.delete(divisionNumber);
        delete boxElement.dataset.fileName;
        boxElement.innerHTML = `<span>Page ${divisionNumber}</span>`;
        boxElement.classList.add('empty-state');
        boxElement.classList.remove('filled-state');
        boxElement.style.filter = 'none';
        boxElement.style.backgroundImage = 'none';
    }
}

/* ---------- Render files (images & PDFs) ---------- */
async function renderFileInBox(boxElement, fileOrEntry) {
    return new Promise((resolve, reject) => {
        boxElement.innerHTML = ''; 
        const emptyClasses = ['color-a','color-b','color-c','color-d']; 
        boxElement.classList.remove('empty-state', ...emptyClasses); 
        boxElement.classList.add('filled-state'); 
        boxElement.style.backgroundImage = 'none'; 
        boxElement.style.position = 'relative';

        // Add file name overlay for better UX
        const fileNameSpan = document.createElement('span');
        fileNameSpan.classList.add('file-name-overlay');
        fileNameSpan.style.cssText = 'position:absolute; bottom:2px; right:2px; background:rgba(0,0,0,0.6); color:white; padding:1px 4px; font-size:8px; border-radius:3px; max-width:90%; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; z-index:10; pointer-events:none;';
        
        // Apply image filter if stored in data attributes
        boxElement.style.filter = boxElement.dataset.filter || 'none';

        if (isPdfPageEntry(fileOrEntry)) {
            const pdfId = fileOrEntry.pdfId;
            const pageNum = fileOrEntry.pageNumber;
            const fileName = fileOrEntry.origName || `PDF-${pdfId}`;

            fileNameSpan.textContent = `${fileName} (p${pageNum})`;
            boxElement.dataset.fileName = fileNameSpan.textContent;

            const pdf = loadedPDFs.get(pdfId);
            if (!pdf) {
                boxElement.innerHTML = `<span>Error: PDF Document ID ${pdfId} not found.</span>`;
                reject(new Error(`PDF ID ${pdfId} not found`));
                return;
            }

            pdf.getPage(pageNum).then(page => {
                const viewport = page.getViewport({ scale: CURRENT_RENDER_SCALE });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = Math.round(viewport.width);
                canvas.height = Math.round(viewport.height);
                canvas.style.width = '100%';
                canvas.style.height = '100%';

                boxElement.innerHTML = ''; // Clear loading indicator

                const renderContext = { canvasContext: context, viewport: viewport };
                page.render(renderContext).promise.then(() => {
                    boxElement.appendChild(canvas);
                    boxElement.appendChild(fileNameSpan);
                    resolve();
                }).catch(err => {
                    boxElement.innerHTML = `<span>Error rendering PDF page: ${err.message}</span>`;
                    reject(err);
                });
            }).catch(err => {
                boxElement.innerHTML = `<span>Error getting PDF page: ${err.message}</span>`;
                reject(err);
            });
            return;
        }

        const file = fileOrEntry; 
        if (file && file.type && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = document.createElement('img');
                img.src = event.target.result;
                img.alt = file.name || 'image';
                img.style.filter = boxElement.dataset.filter || 'none';
                
                fileNameSpan.textContent = file.name || 'image';
                boxElement.dataset.fileName = fileNameSpan.textContent;

                boxElement.appendChild(img);
                boxElement.appendChild(fileNameSpan);
                resolve();
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
            return;
        }
        
        fileNameSpan.textContent = fileOrEntry.name || 'Unsupported';
        boxElement.dataset.fileName = fileNameSpan.textContent;
        boxElement.innerHTML = `<span>File: ${fileOrEntry.name || 'Unsupported Preview'}</span>`;
        boxElement.appendChild(fileNameSpan);
        resolve();
    });
}

/* ---------- Drag & Drop and Box interactions (kept as original) ---------- */
function handleDragOver(e) { e.preventDefault(); if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) e.currentTarget.style.border = '2px solid blue'; }
function handleDragLeave(e) { e.currentTarget.style.border = '1px dashed #ccc'; }
function handleDrop(e) { 
    e.preventDefault();
    handleDragLeave(e);
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
        const file = files[0];
        const boxElement = e.currentTarget;
        const divisionNumber = parseInt(boxElement.id.split('-')[2]);

        if (file.type === 'application/pdf') {
            placePdfFileStartingAtBox(file, divisionNumber);
        } else if (file.type.startsWith('image/')) {
            boxFileMap.set(divisionNumber, file);
            boxElement.dataset.fileName = file.name;
            renderFileInBox(boxElement, file).catch(err => {
                console.error(err);
                boxFileMap.delete(divisionNumber);
                delete boxElement.dataset.fileName;
            });
        } else {
            alert('Unsupported file type.');
        }
    }
}
function handleBoxClick(e) { 
    const box = e.currentTarget;
    if (e.button === 2) { 
        e.preventDefault(); 
        if (box.dataset.fileName) showContextMenu(box, e.clientX, e.clientY);
        return; 
    } 
    if (e.button === 0 && box.dataset.fileName) { 
        activeBoxElement = box; 
        openEditingModal('üí° Photo Adjust'); 
    }
}

/* ---------- Paper Structure & Size functions (kept as original) ---------- */
function updateMargins() {
    marginTop = parseFloat(document.getElementById('margin-top').value) || 0;
    marginBottom = parseFloat(document.getElementById('margin-bottom').value) || 0;
    marginLeft = parseFloat(document.getElementById('margin-left').value) || 0;
    marginRight = parseFloat(document.getElementById('margin-right').value) || 0;
    
    document.querySelectorAll('.paper').forEach(p => {
        p.querySelector('.grid-container').style.padding = `${marginTop}mm ${marginRight}mm ${marginBottom}mm ${marginLeft}mm`;
    });

    if (document.getElementById('box-width').getAttribute('data-calculated') === 'true') {
        calculateConstrainedBoxSize();
    }
}

function updateGapSizes() {
    currentColGap = parseFloat(document.getElementById('col-gap-input').value) || 0;
    currentRowGap = parseFloat(document.getElementById('row-gap-input').value) || 0;

    document.querySelectorAll('.grid-container').forEach(container => {
        container.style.gridColumnGap = `${currentColGap}mm`;
        container.style.gridRowGap = `${currentRowGap}mm`;
    });

    if (document.getElementById('box-width').getAttribute('data-calculated') === 'true') {
        calculateConstrainedBoxSize();
    }
}

function updateDivisionSize() {
    const newW = parseFloat(document.getElementById('box-width').value) || 0;
    const newH = parseFloat(document.getElementById('box-height').value) || 0;

    if (newW > 0 && newH > 0) {
        currentBoxWidth = newW;
        currentBoxHeight = newH;
        isCustomSize = true;
        document.getElementById('box-width').setAttribute('data-calculated','false');
        document.getElementById('box-height').setAttribute('data-calculated','false');

        document.querySelectorAll('.grid-container').forEach(container => {
            container.style.gridTemplateColumns = `repeat(${currentLayout.cols}, ${currentBoxWidth}mm)`;
            container.style.gridTemplateRows = `repeat(${currentLayout.rows}, ${currentBoxHeight}mm)`;
        });
    } else {
        // If user clears the input, revert to calculated size
        document.getElementById('box-width').setAttribute('data-calculated','true');
        document.getElementById('box-height').setAttribute('data-calculated','true');
        calculateConstrainedBoxSize();
    }
}

function calculateConstrainedBoxSize() {
    const baseSize = PAPER_SIZES[currentPaperSize];
    const paperWidth = currentOrientation === 'portrait' ? baseSize.w : baseSize.h;
    const paperHeight = currentOrientation === 'portrait' ? baseSize.h : baseSize.w;

    const boxWInput = document.getElementById('box-width');
    const boxHInput = document.getElementById('box-height');

    const totalHorizontalMargin = marginLeft + marginRight;
    const totalVerticalMargin = marginTop + marginBottom;
    const totalColGap = currentColGap * (currentLayout.cols - 1);
    const totalRowGap = currentRowGap * (currentLayout.rows - 1);

    const availableWidth = paperWidth - totalHorizontalMargin - totalColGap;
    const availableHeight = paperHeight - totalVerticalMargin - totalRowGap;

    const newWidth = availableWidth / currentLayout.cols;
    const newHeight = availableHeight / currentLayout.rows;

    currentBoxWidth = Math.max(1, newWidth);
    currentBoxHeight = Math.max(1, newHeight);

    boxWInput.value = currentBoxWidth.toFixed(1);
    boxHInput.value = currentBoxHeight.toFixed(1);
    boxWInput.setAttribute('data-calculated','true');
    boxHInput.setAttribute('data-calculated','true');

    document.getElementById('add-page-btn').textContent = `‚ûï Add Empty Page (${currentLayout.boxesPerPage} Divisions)`;
}

function applyGridStyles(container) {
    container.style.padding = `${marginTop}mm ${marginRight}mm ${marginBottom}mm ${marginLeft}mm`;
    container.style.gridTemplateColumns = `repeat(${currentLayout.cols}, ${currentBoxWidth}mm)`;
    container.style.gridTemplateRows = `repeat(${currentLayout.rows}, ${currentBoxHeight}mm)`;
    container.style.gridColumnGap = `${currentColGap}mm`;
    container.style.gridRowGap = `${currentRowGap}mm`;
}

function createPage(pageIndex){
    const wrapper = document.getElementById('page-wrapper');
    const pageDiv = document.createElement('div');
    pageDiv.classList.add(`${currentPaperSize}-page`, 'paper');
    pageDiv.id = `page-${pageIndex}`;
    
    if (currentOrientation === 'landscape') pageDiv.classList.add('landscape');
    if (document.getElementById('togglePaperBtn').textContent === 'Show Screen Paper') pageDiv.classList.add('hidden');

    const gridContainer = document.createElement('div');
    gridContainer.classList.add('grid-container');
    applyGridStyles(gridContainer);
    
    const colorClasses = ['color-a','color-b','color-c','color-d'];

    for (let i=0;i<currentLayout.boxesPerPage;i++){
        const box = document.createElement('div');
        box.classList.add('box');
        box.id = `box-div-${nextDivisionNumber}`;
        box.innerHTML = `<span>Page ${nextDivisionNumber}</span>`;
        
        const colorIndex = (nextDivisionNumber - 1) % colorClasses.length;
        box.classList.add('empty-state', colorClasses[colorIndex]);
        
        box.addEventListener('dragover', handleDragOver);
        box.addEventListener('dragleave', handleDragLeave);
        box.addEventListener('drop', handleDrop);
        box.addEventListener('click', handleBoxClick);
        box.addEventListener('contextmenu', handleBoxClick);
        
        // Re-render existing content if available
        if (boxFileMap.has(nextDivisionNumber)) {
            const file = boxFileMap.get(nextDivisionNumber);
            box.dataset.fileName = file.name || (file.origName ? file.origName + ` (p${file.pageNumber})` : `Box ${nextDivisionNumber}`);
            box.classList.remove('empty-state', colorClasses[colorIndex]);
            box.classList.add('filled-state');
            // No need to wait for rendering here, it will be done asynchronously
            renderFileInBox(box, file).catch(err => console.error('Error re-rendering existing box:', err));
        }

        gridContainer.appendChild(box);
        nextDivisionNumber++;
    }

    pageDiv.appendChild(gridContainer);
    wrapper.appendChild(pageDiv);
}

function resetPaper() {
    const wrapper = document.getElementById('page-wrapper');
    const oldPaperElements = document.querySelectorAll('.paper');
    const isHidden = document.getElementById('togglePaperBtn').textContent === 'Show Screen Paper';

    wrapper.innerHTML = '';
    
    // Recalculate size unless it's a custom size
    if (!isCustomSize) {
        calculateConstrainedBoxSize();
    } else {
        // Apply custom size visually
        updateDivisionSize();
    }

    // Reset pagination variables
    currentPageIndex = 0;
    nextDivisionNumber = 1;

    // Determine how many pages to recreate (based on the highest division number in the map)
    let maxDivision = 0;
    if (boxFileMap.size > 0) {
        maxDivision = Math.max(...boxFileMap.keys());
    }

    let requiredPages = Math.ceil(maxDivision / currentLayout.boxesPerPage);
    
    if (requiredPages === 0) {
        requiredPages = 2; // Create at least two pages if empty
    }

    for (let i = 1; i <= requiredPages; i++) {
        currentPageIndex = i;
        createPage(currentPageIndex);
    }
    
    // Ensure the toggle state is reapplied if the pages were hidden
    if (isHidden) {
        document.querySelectorAll('.paper').forEach(p => p.classList.add('hidden'));
    }
}

function handlePaperSizeChange(newSize) {
    currentPaperSize = newSize;
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    resetPaper();
}

function handleDivisionChange(newDivision) {
    currentDivision = newDivision;
    currentLayout = DIVISION_LAYOUTS[newDivision];
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    updateUploadModes(newDivision);
    resetPaper();
}

function handleOrientationChange(newOrientation) {
    currentOrientation = newOrientation;
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    resetPaper();
}

function updateUploadModes(division) {
    const allModes = document.querySelectorAll('#upload-mode-controls label');
    let serialChecked = false;
    allModes.forEach(label => {
        const supportedDivisions = label.dataset.division.split(',');
        const isSupported = supportedDivisions.includes(division);
        label.style.display = isSupported ? 'flex' : 'none';

        if (isSupported) {
            const radio = label.querySelector('input[type="radio"]');
            if (radio.value === uploadMode) {
                radio.checked = true;
                serialChecked = true;
            } else if (radio.value === 'serial' && !serialChecked) {
                radio.checked = true;
                uploadMode = 'serial';
                serialChecked = true;
            }
        }
    });

    const currentModeSupported = document.querySelector(`#upload-mode-controls input[value="${uploadMode}"]`)?.closest('label')?.style.display === 'flex';
    if (!currentModeSupported) {
        document.querySelector(`#upload-mode-controls input[value="serial"]`).checked = true;
        uploadMode = 'serial';
    }
}

window.addNewPage = function() {
    currentPageIndex++;
    createPage(currentPageIndex);
    const newPage = document.getElementById(`page-${currentPageIndex}`);
    // Scroll to the new page
    if (newPage) newPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function getNextSerialBoxID() {
    let nextID = 1;
    // Find the next available ID by checking the map
    while (boxFileMap.has(nextID)) {
        nextID++;
    }
    return nextID;
}

function getInterleavedID(mode) {
    const boxesPerPage = currentLayout.boxesPerPage;
    const filledIndex = currentInterleavedFileIndex;

    const blockNumber = Math.floor(filledIndex / boxesPerPage);
    const boxIndexInBlock = filledIndex % boxesPerPage;
    
    let targetBoxIndex = boxIndexInBlock;

    if (mode === 'interleaved-A' && boxesPerPage === 2) {
        if (boxIndexInBlock === 1) targetBoxIndex = 0; else targetBoxIndex = 1; // 0, 1 -> 1, 0. This is actually standard reverse. Let's stick to the user's description.
        // User's description: 1, 3, 2, 4
        // Page 1 (boxes 1, 2): 1 -> 1, 2 -> 3 (i.e. next page, box 1)
        // Page 2 (boxes 3, 4): 3 -> 2, 4 -> 4 (i.e. next page, box 2)
        // This suggests: (file#1 -> box#1), (file#2 -> box#3), (file#3 -> box#2), (file#4 -> box#4)
        // Pattern: (n*2 + 1), (n*2 + 3), (n*2 + 2), (n*2 + 4) -- for boxesPerPage=2
        // Since we are tracking the next *file* index, let's use the file index.

        // File index (0-based) -> Box ID (1-based)
        // 0 -> 1, 1 -> 3, 2 -> 2, 3 -> 4, 4 -> 5, 5 -> 7, 6 -> 6, 7 -> 8
        // If file_idx is even (0, 2, 4, 6), target_box = file_idx + 1 (1, 3, 5, 7)
        // If file_idx is odd (1, 3, 5, 7), target_box = file_idx + 2 (3, 5, 7, 9)

        // Correction based on user's pattern: 1, 3, 2, 4
        // File#1 (idx 0) -> Box 1 (1+0)
        // File#2 (idx 1) -> Box 3 (1+2)
        // File#3 (idx 2) -> Box 2 (1+1)
        // File#4 (idx 3) -> Box 4 (1+3)
        // This pattern does not seem to fit.

        // Standard Interleaved (1, 5, 2, 6) for 2x2 = 4 boxes/page
        // File 1 -> Box 1 (Page 1)
        // File 2 -> Box 5 (Page 2)
        // File 3 -> Box 2 (Page 1)
        // File 4 -> Box 6 (Page 2)

        // We use the file index for interleaving logic, then calculate the target box ID.
        // The box ID is 1-based, sequential.

        let targetID = 0;
        let pagesToSkip = currentLayout.boxesPerPage === 2 ? 1 : 2; // For 2 boxes/page, skip 1 page (box 1 -> 3). For 4, skip 2 pages (box 1 -> 5).

        if (mode === 'interleaved-A' && boxesPerPage === 2) {
            // Pattern: 1, 3, 2, 4, 5, 7, 6, 8...
            // File index: 0, 1, 2, 3, 4, 5, 6, 7...
            if (filledIndex % 4 < 2) {
                // files 0, 1, 4, 5... go to odd boxes (1, 3, 5, 7...)
                targetID = (Math.floor(filledIndex / 2) * 2) + 1 + (filledIndex % 2) * 2;
            } else {
                // files 2, 3, 6, 7... go to even boxes (2, 4, 6, 8...)
                targetID = (Math.floor(filledIndex / 2) * 2) + 2 - (filledIndex % 2) * 2;
            }
        } else if (mode === 'interleaved-standard' && boxesPerPage === 4) {
            // Pattern: 1, 5, 2, 6, 3, 7, 4, 8...
            // Base ID for current page (1 or 2): filledIndex % boxesPerPage
            // Page offset (0 or 4): Math.floor(filledIndex / boxesPerPage) * 4
            const pageInBlock = filledIndex % boxesPerPage;
            const blockCycle = Math.floor(filledIndex / boxesPerPage); // 0, 1, 2, 3...
            const boxIndexOnSheet = Math.floor(pageInBlock / 2) + (pageInBlock % 2) * 2; // Maps 0,1,2,3 to 0,2,1,3 (approx 1,2,3,4 to 1,3,2,4 on sheet)
            
            // Simplified: Page 1 receives files 1,3,5,7...; Page 2 receives files 2,4,6,8...
            const fileIsOdd = (filledIndex % 2) === 0; // File 1, 3, 5... (index 0, 2, 4...) -> Page 1
            const filePosInGroup = Math.floor(filledIndex / 2); // 0, 1, 2, 3...
            const pageMultiplier = fileIsOdd ? 0 : boxesPerPage;
            targetID = (filePosInGroup % boxesPerPage) + 1 + pageMultiplier + (Math.floor(filePosInGroup / boxesPerPage) * boxesPerPage * 2);
        } else if (mode === 'interleaved-custom' && boxesPerPage === 4) {
            // Pattern: 1, 6, 2, 5, 3, 8, 4, 7...
            // This is standard-like but file 2 and 4 are swapped.
            // File 1 -> Box 1, File 2 -> Box 6, File 3 -> Box 2, File 4 -> Box 5.
            const fileIsOdd = (filledIndex % 2) === 0;
            const filePosInGroup = Math.floor(filledIndex / 2);
            const pageMultiplier = fileIsOdd ? 0 : boxesPerPage;
            let boxIndex = (filePosInGroup % boxesPerPage) + 1;
            
            // Custom swap logic for file 2 and 4 (index 1 and 3)
            if (!fileIsOdd) { // For the even files (index 1, 3, 5...)
                 if (boxIndex === 2) boxIndex = 1; else if (boxIndex === 1) boxIndex = 2; // Swap 1 and 2 (Box 5 and 6)
            }
            targetID = boxIndex + pageMultiplier + (Math.floor(filePosInGroup / boxesPerPage) * boxesPerPage * 2);
        } else {
             // Fallback to Serial
             return getNextSerialBoxID();
        }
        
        // Final check to see if the calculated ID is already filled (only relevant for interleaved)
        if (boxFileMap.has(targetID)) {
            // If the target slot is already filled, we must use the next available serial slot.
            // This happens if files are uploaded outside of a full interleaved set (e.g., upload 1 file, then another in serial mode).
            // For now, as per instruction in handleFile, we warn and stop. For multi-upload, this is more complex.
            // We'll rely on the check in handleFile/handlePdfFile for now and simplify the ID calculation here to the base.
            return targetID;
        }

        return targetID;
    }
    return getNextSerialBoxID();
}

function getNextTargetBoxID() {
    if (currentDivision === '1') {
        uploadMode = 'serial';
        document.querySelector(`#upload-mode-controls input[value="serial"]`).checked = true;
    }

    if (uploadMode === 'serial') {
        currentInterleavedFileIndex = 0;
        return getNextSerialBoxID();
    } else {
        let filledCount = 0;
        // The interleaved index should be the count of all files placed so far, *not* just the ones on the first page.
        // It must be derived from the highest occupied box ID and the known layout.
        // For simplicity and to match the existing logic which uses `filledCount`, we'll use a simple count from 1 to nextDivisionNumber.

        // We use the count of files *placed* in the map to determine the index in the interleaved sequence.
        // Note: The original logic in the provided code calculates `filledCount` this way:
        for (let i = 1; i < nextDivisionNumber; i++) {
             if (boxFileMap.has(i)) filledCount++;
        }
        currentInterleavedFileIndex = filledCount;
        return getInterleavedID(uploadMode);
    }
}

function checkAndCreatePages(requiredID) {
    while (requiredID >= nextDivisionNumber) {
        currentPageIndex++;
        createPage(currentPageIndex);
        const newPage = document.getElementById(`page-${currentPageIndex}`);
        // Ensure new pages created are hidden if the paper is hidden
        if (newPage && document.getElementById('togglePaperBtn').textContent === 'Hide Screen Paper') {
            newPage.classList.add('hidden');
        }
    }
}

/* ---------- File upload handlers (OPTIMIZED FOR PDF SPEED) ---------- */
function handleMultiPhotoUpload(files){
    if (!files || files.length === 0) return;
    Array.from(files).forEach(f => {
        if (f.type === 'application/pdf') handlePdfFile(f);
        else if (f.type.startsWith('image/')) handleFile(f);
        else alert(`File ${f.name} skipped: Only Images and PDFs are supported.`);
    });
}

function handleFile(file) {
    const targetID = getNextTargetBoxID();

    if (uploadMode !== 'serial' && boxFileMap.has(targetID)) {
        alert(`File ${file.name} skipped: The next calculated slot (Box ${targetID}) is already filled. Use Serial mode or delete existing content.`);
        currentInterleavedFileIndex--; // Decrement as we didn't place the file
        return;
    }

    checkAndCreatePages(targetID);
    
    const box = document.getElementById(`box-div-${targetID}`);
    if (box) {
        boxFileMap.set(targetID, file);
        box.dataset.fileName = file.name;
        renderFileInBox(box, file).catch(error => {
            console.error(`Error rendering file ${file.name} in box ${targetID}:`, error);
            boxFileMap.delete(targetID); // Clean up on error
            delete box.dataset.fileName;
        });
    }
}

function handlePdfFile(file) {
    document.getElementById('multi-upload-btn').textContent = `...Loading PDF ${file.name}...`;

    const reader = new FileReader();
    reader.onload = function(ev) {
        const arrayBuffer = ev.target.result;
        const pdfId = nextPdfId++; // Get a unique ID for this PDF
        
        pdfjsLib.getDocument({ data: arrayBuffer }).promise.then(pdfDoc => {
            loadedPDFs.set(pdfId, pdfDoc);
            const total = pdfDoc.numPages;

            for (let p = 1; p <= total; p++) {
                const targetID = getNextTargetBoxID();
                
                if (uploadMode !== 'serial' && boxFileMap.has(targetID)) {
                    // Only alert and stop PDF if one of the intended interleaved slots is filled.
                    alert(`PDF ${file.name} stopped at page ${p}: The intended slot (Box ${targetID}) is already filled. Remaining pages skipped.`);
                    // Decrement interleaved index for the pages we didn't process
                    currentInterleavedFileIndex -= (total - p + 1); 
                    break;
                }

                // 1. Ensure page exists for target ID (Create if needed)
                checkAndCreatePages(targetID);
                const box = document.getElementById(`box-div-${targetID}`);
                if (!box) {
                    // This should theoretically not happen if checkAndCreatePages works, but for safety:
                    console.error('Target box not found after creation check:', targetID);
                    break; 
                }

                // 2. Create the file entry (kind: 'pdfpage' for easy type check)
                const entry = { kind: 'pdfpage', pdfId: pdfId, pageNumber: p, name: `${file.name} (p${p})`, origName: file.name };
                
                // 3. Store in the global map for rendering
                boxFileMap.set(targetID, entry);
                box.dataset.fileName = entry.name;
                
                // 4. Render asynchronously - this part is the only one that takes time, but the map is updated instantly. 
                // We don't wait for the render.
                renderFileInBox(box, entry).catch(err => console.error('PDF page render error:', err));
            }
            document.getElementById('multi-upload-btn').textContent = `‚ûï Choose Files (Images/PDF)`;

        }).catch(err => {
            alert('Failed to parse PDF: ' + err.message);
            console.error(err);
            document.getElementById('multi-upload-btn').textContent = `‚ûï Choose Files (Images/PDF)`;
        });
    };
    reader.onerror = function(err) {
        alert('Failed to read PDF file.');
        console.error(err);
        document.getElementById('multi-upload-btn').textContent = `‚ûï Choose Files (Images/PDF)`;
    };
    reader.readAsArrayBuffer(file);
}

function placePdfFileStartingAtBox(file, startBoxId) {
    const reader = new FileReader();
    reader.onload = function(ev) {
        const arrayBuffer = ev.target.result;
        const pdfId = nextPdfId++;
        pdfjsLib.getDocument({ data: arrayBuffer }).promise.then(pdfDoc => {
            loadedPDFs.set(pdfId, pdfDoc);
            let pointer = startBoxId;
            const total = pdfDoc.numPages;

            // 1. Delete existing files from startBoxId onwards (if they were part of the previous PDF)
            // This is actually tricky because a new PDF might replace a different PDF that was already filling subsequent boxes.
            // For simplicity, we just delete the immediate box and rely on the new PDF to overwrite everything else sequentially.
            // The main `deleteFileFromBox` does a better cleanup for one full PDF, but here we are placing a new one.

            // Clear the existing entry for the start box only (new pages will fill over existing non-pdf entries anyway)
            const existingBox = document.getElementById(`box-div-${startBoxId}`);
            if(existingBox && boxFileMap.has(startBoxId)) deleteFileFromBox(existingBox); 


            // 2. Synchronously map new PDF pages
            for (let p = 1; p <= total; p++) {
                checkAndCreatePages(pointer);
                const box = document.getElementById(`box-div-${pointer}`);

                if (!box) {
                    pointer++;
                    continue;
                }

                const entry = { kind: 'pdfpage', pdfId: pdfId, pageNumber: p, name: `${file.name} (p${p})`, origName: file.name };
                boxFileMap.set(pointer, entry);
                box.dataset.fileName = entry.name;

                // Render asynchronously
                renderFileInBox(box, entry).catch(err => console.error('PDF page render error:', err));
                pointer++;
            }
        }).catch(err => {
            alert('Failed to parse PDF: ' + err.message);
            console.error(err);
        });
    };
    reader.readAsArrayBuffer(file);
}

/* ---------- Save functions (MODIFIED) ---------- */
window.saveSheetsAsFile = async function() {
    const saveBtn = document.getElementById('save-sheets-btn');
    const controlsContainer = document.getElementById('controls-panel-container');
    const paperWrapper = document.getElementById('page-wrapper');
    const saveType = document.getElementById('save-as-type-select').value;
    const saveQualitySelect = document.getElementById('save-quality-select');
    
    // Check if there's anything to save first
    const paperElements = document.querySelectorAll('#page-wrapper .paper'); // Select ALL paper elements, regardless of visibility
    if (paperElements.length === 0) {
        alert('No sheets to save.');
        return;
    }

    // --- Start of Visibility Management (ADDED) ---
    const hiddenPages = [];
    paperElements.forEach(p => {
        if (p.classList.contains('hidden')) {
            hiddenPages.push(p);
            p.classList.remove('hidden'); // Make the page visible for capture
        }
    });
    // --- End of Visibility Management (ADDED) ---

    // Configuration for html2canvas
    const selectedQualityScale = saveQualitySelect.value;
    const CAPTURE_SCALE = parseFloat(selectedQualityScale);
    const qualityText = saveQualitySelect.options[saveQualitySelect.selectedIndex].textContent;
    
    saveBtn.disabled = true;
    saveBtn.innerHTML = `‚è±Ô∏è Processing (${qualityText})...`;

    const fileName = `All-in-one-minimize`;
    let wasControlsOpen = false;
    if (!controlsContainer.classList.contains('hidden')) {
        controlsContainer.classList.add('hidden');
        wasControlsOpen = true;
    }

    // Hide file name overlays before capture
    paperWrapper.classList.add('hide-overlays');

    try {
        if (saveType === 'doc' || saveType === 'docx') {
            saveBtn.innerHTML = `‚è±Ô∏è Generating ${saveType.toUpperCase()}...`;
            const fileContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>${fileName}</title>
                    <meta name="viewport" content="width=device-width,initial-scale=1">
                    <style>
                        .paper { 
                            width: ${currentOrientation === 'landscape' ? PAPER_SIZES[currentPaperSize].h : PAPER_SIZES[currentPaperSize].w}mm; 
                            min-height: ${currentOrientation === 'landscape' ? PAPER_SIZES[currentPaperSize].w : PAPER_SIZES[currentPaperSize].h}mm; 
                            margin: 0 auto 20px; 
                            box-shadow: none; 
                            border: 1px solid #ccc; 
                            padding: ${marginTop}mm ${marginRight}mm ${marginBottom}mm ${marginLeft}mm; /* Use actual margins */
                            box-sizing: border-box; 
                            page-break-after: always; 
                        }
                        .box { border: 1px solid #eee; min-height: 100px; padding: 5px; margin-bottom: 5px; }
                        /* Ensure only images show for doc/docx, canvas is PDF preview */
                        .box canvas { display: none; }
                        .box img { max-width: 100%; height: auto; display: block; filter: inherit; } 
                        .grid-container { 
                            display: grid; 
                            grid-template-columns: repeat(${currentLayout.cols}, ${currentBoxWidth}mm); 
                            grid-template-rows: repeat(${currentLayout.rows}, ${currentBoxHeight}mm); 
                            grid-column-gap: ${currentColGap}mm; 
                            grid-row-gap: ${currentRowGap}mm; 
                            width: 100%; 
                            height: 100%;
                        }
                        @page { margin: 1in; }
                    </style>
                </head>
                <body>
                    <h1>${fileName} - Saved as Editable HTML (${saveType.toUpperCase()})</h1>
                    <p>Note: This file was saved as HTML with the .${saveType} extension. Layout precision depends on the word processor's HTML rendering.</p>
                    ${paperWrapper.innerHTML}
                </body>
                </html>
            `.trim();
            const blob = new Blob([fileContent], { type: 'application/msword;charset=utf-8' });
            saveAs(blob, `${fileName}.${saveType}`);
            alert(`Sheets successfully saved as ${saveType.toUpperCase()}.`);

        } else if (saveType === 'pdf') {
            saveBtn.innerHTML = `‚è±Ô∏è Creating final PDF...`;
            const { jsPDF } = window.jspdf;
            
            let pdf = null;
            for (let idx = 0; idx < paperElements.length; idx++) {
                const paper = paperElements[idx];
                const rect = paper.getBoundingClientRect();
                saveBtn.innerHTML = `‚è±Ô∏è Processing Page ${idx + 1} of ${paperElements.length}...`;
                
                // html2canvas capture logic remains the same, it will now capture the temporarily unhidden pages
                const canvas = await html2canvas(paper, {
                    scale: CAPTURE_SCALE,
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null,
                    width: Math.ceil(rect.width),
                    height: Math.ceil(rect.height),
                    windowWidth: document.documentElement.clientWidth,
                    windowHeight: document.documentElement.clientHeight,
                    scrollX: -window.scrollX - rect.left,
                    scrollY: -window.scrollY - rect.top
                });

                const imgData = canvas.toDataURL('image/jpeg', 1.0);
                const baseSize = PAPER_SIZES[currentPaperSize];
                let pdfWidthMM = baseSize.w;
                let pdfHeightMM = baseSize.h;
                let orientation = 'portrait';

                if (paper.classList.contains('landscape')) {
                    orientation = 'landscape';
                    pdfWidthMM = baseSize.h;
                    pdfHeightMM = baseSize.w;
                }

                if (!pdf) {
                    pdf = new jsPDF({
                        orientation: orientation,
                        unit: 'mm',
                        format: [pdfWidthMM, pdfHeightMM]
                    });
                    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidthMM, pdfHeightMM, undefined, 'FAST');
                } else {
                    pdf.addPage([pdfWidthMM, pdfHeightMM], orientation.toLowerCase());
                    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidthMM, pdfHeightMM, undefined, 'FAST');
                }
            }

            if (pdf) {
                pdf.save(`${fileName}.pdf`);
                alert(`Sheets successfully saved as multi-page PDF...`);
            }

        } else if (saveType === 'png' || saveType === 'jpg') {
            // PNG / JPG save logic
            saveBtn.innerHTML = `‚è±Ô∏è Creating final ${saveType.toUpperCase()}...`;

            if (paperElements.length > 1) {
                alert(`Saving as ${saveType.toUpperCase()} is only supported for a single sheet. Please print if you have multiple pages.`);
                return;
            }

            const paper = paperElements[0];
            const rect = paper.getBoundingClientRect();
            
            const canvas = await html2canvas(paper, {
                scale: CAPTURE_SCALE,
                allowTaint: true,
                useCORS: true,
                backgroundColor: null,
                width: Math.ceil(rect.width),
                height: Math.ceil(rect.height),
                windowWidth: document.documentElement.clientWidth,
                windowHeight: document.documentElement.clientHeight,
                scrollX: -window.scrollX - rect.left,
                scrollY: -window.scrollY - rect.top
            });

            // Fallback for file saver if not loaded (not needed if using saveAs from jsPDF)
            const saveAs = (typeof window.saveAs === 'function') ? window.saveAs : (blob, filename) => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            };

            if (saveType === 'png') {
                canvas.toBlob(function(blob) {
                    saveAs(blob, `${fileName}.png`);
                    alert(`Sheet successfully saved as PNG image.`);
                }, 'image/png');
            } else if (saveType === 'jpg') {
                canvas.toBlob(function(blob) {
                    saveAs(blob, `${fileName}.jpg`);
                    alert(`Sheet successfully saved as JPEG image.`);
                }, 'image/jpeg', 0.9); // 90% quality for JPG
            }

        } else {
            alert(`Unsupported save type: ${saveType}.`);
        }
    } catch (error) {
        console.error('Save failed:', error);
        alert('An error occurred during save. Check the console for details. Error: ' + error.message);
    } finally {
        // --- Restore Visibility Management (ADDED) ---
        hiddenPages.forEach(p => p.classList.add('hidden')); 
        // --- End of Restore Visibility Management (ADDED) ---

        // Cleanup
        saveBtn.disabled = false;
        if (wasControlsOpen) controlsContainer.classList.remove('hidden');
        paperWrapper.classList.remove('hide-overlays');
        updateSaveButtonText(); // Restore save button text and scale
    }
}


/* ---------- Event Listeners & Initialization (kept as original) ---------- */
function togglePaper() {
    const toggleBtn = document.getElementById('togglePaperBtn');
    const paperElements = document.querySelectorAll('.paper');
    const isHidden = toggleBtn.textContent === 'Show Screen Paper';

    paperElements.forEach(p => {
        if (isHidden) p.classList.remove('hidden');
        else p.classList.add('hidden');
    });

    toggleBtn.textContent = isHidden ? 'Hide Screen Paper' : 'Show Screen Paper';
}

function toggleControls() {
    document.getElementById('controls-panel-container').classList.toggle('hidden');
    const btn = document.getElementById('toggle-controls-btn');
    btn.textContent = document.getElementById('controls-panel-container').classList.contains('hidden') ? '‚óÄ' : '‚ñ∂';
}

function toggleBackground() {
    document.body.classList.toggle('bg-gradient');
    document.body.classList.toggle('bg-image');
}

function handleQualityChange(newScale) {
    CURRENT_RENDER_SCALE = parseFloat(newScale);
    // Force re-render of all boxes that contain images or PDFs
    document.querySelectorAll('.box.filled-state').forEach(box => {
        const divisionNumber = parseInt(box.id.split('-')[2]);
        const entry = boxFileMap.get(divisionNumber);
        if (entry) {
            // Re-render the content at the new scale
            renderFileInBox(box, entry).catch(err => console.error('Quality re-render failed:', err));
        }
    });
}

function updateSaveButtonText() {
    const saveQualitySelect = document.getElementById('save-quality-select');
    const selectedQualityScale = saveQualitySelect.value;
    const saveBtn = document.getElementById('save-sheets-btn');
    const match = saveQualitySelect.options[saveQualitySelect.selectedIndex].textContent.match(/\((.*?)\)/);
    const displayScale = match ? match[1] : `${selectedQualityScale}x`;
    saveBtn.innerHTML = `üíæ Start Save(${displayScale})`;
}

function attachLiveListeners() {
    ['margin-top','margin-bottom','margin-left','margin-right'].forEach(id => document.getElementById(id)?.addEventListener('change', updateMargins));
    ['box-width','box-height'].forEach(id => document.getElementById(id)?.addEventListener('change', updateDivisionSize));
    ['row-gap-input','col-gap-input'].forEach(id => document.getElementById(id)?.addEventListener('change', updateGapSizes));
    document.getElementById('paper-size-select')?.addEventListener('change', e => handlePaperSizeChange(e.target.value));
    document.querySelectorAll('input[name="pageDivision"]').forEach(el => el.addEventListener('change', e => handleDivisionChange(e.target.value)));
    document.querySelectorAll('input[name="paperOrientation"]').forEach(el => el.addEventListener('change', e => handleOrientationChange(e.target.value)));
    document.querySelectorAll('input[name="uploadMode"]').forEach(el => el.addEventListener('change', e => uploadMode = e.target.value));
    
    document.getElementById('multi-upload-btn')?.addEventListener('click', () => document.getElementById('multi-file-input').click());
    document.getElementById('multi-file-input')?.addEventListener('change', e => handleMultiPhotoUpload(e.target.files));
    document.getElementById('toggle-controls-btn')?.addEventListener('click', toggleControls);
    document.getElementById('toggle-bg-btn')?.addEventListener('click', toggleBackground);
    document.getElementById('togglePaperBtn')?.addEventListener('click', togglePaper);
    
    // Quality selector listener
    document.getElementById('quality-select')?.addEventListener('change', e => handleQualityChange(e.target.value));
    document.getElementById('save-quality-select')?.addEventListener('change', updateSaveButtonText);
}

document.addEventListener('DOMContentLoaded', () => {
    attachLiveListeners();
    
    // Initial calculation based on default settings
    marginTop = parseFloat(document.getElementById('margin-top').value) || 0;
    marginBottom = parseFloat(document.getElementById('margin-bottom').value) || 0;
    marginLeft = parseFloat(document.getElementById('margin-left').value) || 0;
    marginRight = parseFloat(document.getElementById('margin-right').value) || 0;
    currentColGap = parseFloat(document.getElementById('col-gap-input').value) || 0;
    currentRowGap = parseFloat(document.getElementById('row-gap-input').value) || 0;
    
    calculateConstrainedBoxSize();
    
    // Manually set box size inputs to reflect the calculated full-page size based on A4/portrait/1x1/0 margins
    document.getElementById('box-width').value = (PAPER_SIZES['a4'].w / DIVISION_LAYOUTS['1'].cols).toFixed(1);
    document.getElementById('box-height').value = (PAPER_SIZES['a4'].h / DIVISION_LAYOUTS['1'].rows).toFixed(1);
    
    // Update Add Page button text to reflect 1 Division
    document.getElementById('add-page-btn').textContent = `‚ûï Add Empty Page (${currentLayout.boxesPerPage} Divisions)`;

    // Set initial quality scales and update save button text
    CURRENT_RENDER_SCALE = SCREEN_MAX_QUALITY_SCALE; // Default for screen is 4.0x
    document.getElementById('quality-select').value = SCREEN_MAX_QUALITY_SCALE.toString();
    document.getElementById('save-quality-select').value = DEFAULT_QUALITY_SCALE.toString(); // Default for save is FAST 2.5x
    updateSaveButtonText();

    // Create two pages by default (keeps your existing behavior)
    currentPageIndex = 1;
    createPage(currentPageIndex);
    currentPageIndex = 2;
    createPage(currentPageIndex);
});
</script>
</body>
</html>
