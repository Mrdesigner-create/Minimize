<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>All-in-one-converter</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Set the worker URL for PDF.js - required.
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // --- OPTIMIZATION: Configurable Quality Scales ---
    // Lowest scale for fastest, lowest resolution rendering.
    const LOW_QUALITY_SCALE = 1.0; 
    // Medium scale for good on-screen quality and FASTEST save speed.
    const DEFAULT_QUALITY_SCALE = 2.5; 
    // Highest practical scale for smooth live screen rendering or better save speed.
    const SCREEN_MAX_QUALITY_SCALE = 4.0; 
    // ULTIMATE scale for final PDF/Image saving and printing. (Highest Quality)
    const FINAL_SAVE_QUALITY_SCALE = 6.0; 

    // Global variable to track the current quality scale for screen rendering and browser printing
    let CURRENT_RENDER_SCALE = 4.0; // Changed default to SCREEN_MAX_QUALITY_SCALE (4.0)

    // Global map to store loaded PDF documents by a unique ID, to avoid reloading
    const loadedPDFs = new Map();
    let nextPdfId = 1;
  </script>

  <style>
    :root { 
        --paper-padding-mm: 10; 
        --toggle-controls-bg: red;    
        --toggle-controls-border: #388E3C;
        --toggle-controls-icon-color: white; 
    }

    body {
      background: url('https://mrdesigner-create.github.io/photoes/Beautiful-Rose.jpg') center/cover no-repeat fixed !important;
      padding: 20px;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
      margin: 0;
      transition: background 0.6s;
    }
    body.bg-gradient { background: linear-gradient(to bottom right, skyblue, #ff4b4b) !important; }

    #page-wrapper { display:flex; flex-direction:column; align-items:flex-start; width:100%; }

    .a4-page { width:210mm; min-height:297mm; }
    .a5-page { width:148mm; min-height:210mm; }
    .a6-page { width:105mm; min-height:148mm; }
    .us-letter-page { width:8.5in; min-height:11in; }
    .a4-page.landscape { width:297mm; min-height:210mm; }
    .a5-page.landscape { width:210mm; min-height:148mm; }
    .a6-page.landscape { width:148mm; min-height:105mm; }
    .us-letter-page.landscape { width:11in; min-height:8.5in; }

    .paper {
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      background:#fff;
      margin-bottom:20px;
      padding:0; 
      box-sizing:border-box;
      position: relative;
    }
    .a4-page.hidden, .a5-page.hidden, .a6-page.hidden, .us-letter-page.hidden { display:none !important; }

    .grid-container { display: grid; width: 100%; height: 100%; }

    .box {
      border: 1px dashed #ccc; 
      display: flex; 
      justify-content: center; 
      align-items: center;
      font-size: 10px;
      color: #999;
      box-sizing: border-box;
      cursor: pointer;
      transition: border-color 0.2s;
      overflow: hidden;
      padding: 0;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      min-width: 0;
      min-height: 0;
      position: relative;
    }
    .box:hover { border-color: #3498db; }
    .box img, .box canvas { width: 100%; height: 100%; object-fit: contain; display: block; margin: auto; }
    .box canvas { max-width: 100%; max-height: 100%; display: block; }

    .box.empty-state.color-a { background-color: #f0f8ff !important; }
    .box.empty-state.color-b { background-color: #fff8e1 !important; }
    .box.empty-state.color-c { background-color: #e1f3e8 !important; }
    .box.empty-state.color-d { background-color: #fbebf7 !important; }

    .box.filled-state { background-color: #e8f5e9 !important; }

    .controls { padding:10px; background:red; border:1px solid #95a5a6; z-index:10000; max-width:360px;
      text-align:center; max-height:80vh; overflow-y:auto; overflow-x:hidden;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.25), inset -2px -2px 5px rgba(255,255,255,0.8);
    }
    .controls-panel-container { position:fixed; top:20px; right:20px; transition:right 1.10s; }
    .controls-panel-container.hidden { right:-382px; }

    #toggle-controls-btn { position:absolute; top:0; left:-54px; height:68px; width:59px; border:1px solid var(--toggle-controls-border); border-right:10px; background:var(--toggle-controls-bg); color: var(--toggle-controls-icon-color); display:flex; align-items:center; justify-content:center; border-radius:22px 0 0 20px; cursor:pointer; box-shadow:-10px 0 8px rgba(0,0,0,0.1); font-size: 24px; }

    #toggle-bg-btn { position:fixed; top:20px; left:20px; background:yellow; border:1px solid red; box-shadow: 0 8px 8px rgba(0,0,0,0.3); padding:8px 8px; cursor:pointer; z-index:10001; }

    .controls button, .controls select, .controls input[type="number"] { padding:10px 12px; margin:6px 0; border:1px solid lightgray; font-size:14px; width:100%; box-sizing:border-box; background-color: white; }
    .controls h4 { margin:10px 0 6px; }
    .hidden-input { display:none; }
    .input-group { display: flex; gap: 5px; }
    .input-group input { width: 50%; }
    .input-group-four { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }

    .input-group-radio {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        background: #eee !important;
        border: 1px solid #aaa !important;
        padding: 5px;
        border-radius: 4px;
    }
    .input-group-radio label {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 4px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 10px;
        cursor: pointer;
        background-color: LightYellow !important;
        color: #333 !important;
        transition: background-color 0.2s;
    }
    .input-group-radio label:hover { background-color: gold !important; }
    .input-group-radio input[type="radio"] { margin-right: 2px; width: auto; display: none; }
    .input-group-radio input[type="radio"]:checked + span {
        font-weight: bold;
        color: white !important;
        background-color: LimeGreen !important;
        border-radius: 4px;
        padding: 4px;
    }
    .input-group-radio label span { pointer-events: none; }

    #context-menu {
        position: fixed;
        background: #fff;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        list-style: none;
        padding: 0;
        margin: 0;
        z-index: 10002;
        display: none;
        min-width: 150px;
    }
    #context-menu li { padding: 8px 12px; cursor: pointer; font-size: 14px; }
    #context-menu li:hover { background: #f0f0f0; }

    #edit-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 10003; }
    .modal-content { background: #333; color: #fff; padding: 25px; border-radius: 12px; width: 95%; max-width: 900px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6); max-height: 90vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease-out; }
    #edit-modal.active .modal-content { transform: scale(1); }
    .modal-content h3 { margin-top: 0; border-bottom: 2px solid #555; padding-bottom: 10px; color: #f39c12; }
    .modal-main-area { display: flex; gap: 20px; }
    .modal-preview-container { flex: 3; min-width: 60%; }
    .modal-sidebar { flex: 1; min-width: 25%; background: #444; padding: 15px; border-radius: 6px; }
    .modal-sidebar label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; color: #ccc;}
    .modal-sidebar input[type="number"] { padding: 8px; width: 100%; box-sizing: border-box; border: 1px solid #666; background: #222; color: #fff; border-radius: 4px; }
    #modal-preview { border: 2px solid #666; min-height: 400px; display: flex; justify-content: center; align-items: center; margin-bottom: 15px; background-color: #222; overflow: hidden; border-radius: 4px; }
    #modal-preview img, #modal-preview canvas { max-width: 100%; max-height: 100%; object-fit: contain; display:block; }

    .modal-actions button { margin: 5px 0; padding: 10px 15px; font-size: 15px; cursor: pointer; width: 100%; border: none; border-radius: 4px; color: #fff; transition: background-color 0.2s; }
    .modal-actions .btn-primary { background-color: #3498db; }
    .modal-actions .btn-replace { background-color: #2ecc71; }
    .modal-actions .btn-crop { background-color: #e67e22; }
    .modal-actions .btn-delete { background-color: #e74c3c; }
    .modal-actions .btn-close { background-color: #555; margin-top: 15px;}
    .modal-actions .btn-adjust { background-color: #f39c12; }

    @media print {
      .controls-panel-container, #toggle-controls-btn, #toggle-bg-btn, #togglePaperBtn, #add-page-btn, #context-menu, #edit-modal, #save-as-type-select, #save-sheets-btn, #quality-select-container, #save-quality-select-container { display:none; }
      body { padding:0; background-color:white; }
      .paper { width:auto !important; min-height:auto !important; margin:0; padding:0; box-shadow:none; page-break-after:always; }
      .a4-page.landscape { -webkit-print-color-adjust: exact; size: A4 landscape !important; }
      .us-letter-page.landscape { -webkit-print-color-adjust: exact; size: letter landscape !important; }
      /* Print will use the ULTIMATE scale (6.0x) for capture via browser's rendering of canvas elements */
      .box { border: none !important; background-color: white !important; }
      .box span { display: none; }
      .box canvas { width: 100%; height: 100%; display: block; }
      @page { margin:0; }
    }
    
    /* ADDED: Style to hide the filename overlay during save capture */
    #page-wrapper.hide-overlays .file-name-overlay {
        display: none !important;
    }

    #togglePaperBtn { background-color: yellow !important; color: black !important; border-color: black !important; font-weight: bold !important; border-width: 2px !important; }
    #paper-size-select { background-color: purple !important; color: white !important; border-color: yellow !important; font-weight: bold !important; border-width: 2px !important; -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important; }
    #print-btn { background-color: crimson !important; color: white !important; border-color: #3498db !important; font-weight: bold !important; border-width: 2px !important; }
    #add-page-btn { background-color: orangered !important; color: white !important; border-color: #333 !important; font-weight: bold !important; border-width: 2px !important; }
    #multi-upload-btn { background-color: deepskyblue !important; color: white !important; border-color: navy !important; font-weight: bold !important; border-width: 2px !important; }
    #save-sheets-btn { background-color: darkgreen !important; color: white !important; border-color: #333 !important; font-weight: bold !important; border-width: 2px !important; transition: background-color 0.15s, opacity 0.15s; }
    #save-as-type-select { background-color: LightCoral !important; color: white !important; border-color: #333 !important; font-weight: bold !important; border-width: 2px !important; -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important;}
    #quality-select, #save-quality-select { background-color: LightBlue !important; color: #333 !important; border-color: navy !important; font-weight: bold !important; border-width: 2px !important; -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important;}

    .controls input[type="number"] { background-color: LightCyan !important; color: #333 !important; border: 2px solid DarkCyan !important; }

  </style>
</head>
<body class="bg-image">

  <button id="toggle-bg-btn">üíß Show/Hide</button>

  <div id="controls-panel-container" class="controls-panel-container hidden">
    <div class="controls">
      <button id="toggle-controls-btn">‚óÄ</button>

      <div id="controls-content">
        <button id="togglePaperBtn">Show Screen Paper</button>
        <button id="add-page-btn" onclick="addNewPage()">‚ûï Add Empty Page (1 Divisions)</button> 
        
        <div id="quality-select-container">
            <h4>‚öôÔ∏è Screen/Preview Quality (Speed):</h4> 
            <select id="quality-select">
                <option value="1.0">Fastest (Low Quality - 1.0x)</option>
                <option value="2.5">Better (Good Quality - 2.5x)</option>
                <option value="4.0" selected>Highest (Max Speed/Quality Balance - 4.0x)</option>
                <option value="6.0">Ultimate Quality (Slowest Re-render - 6.0x)</option>
            </select>
            <p style="font-size:.85em; margin-top:10px;">Note: Changing this will re-render everything.</p>
        </div>

        <h4>‚ûó Division Layout:</h4>
        <div id="division-controls" class="input-group-radio"> 
            <label>
                <input type="radio" name="pageDivision" value="1" checked> <span>Divide 1 (1x1)</span>
            </label>
            <label>
                <input type="radio" name="pageDivision" value="2">
                <span>Divide 2 (1x2)</span>
            </label>
            <label>
                <input type="radio" name="pageDivision" value="4">
                <span>Divide 4 (2x2)</span>
            </label>
        </div>

        <h4>üß≠ Orientation:</h4>
        <div id="orientation-controls" class="input-group-radio"> <label>
                <input type="radio" name="paperOrientation" value="portrait" checked>
                <span>Portrait</span>
            </label>
            <label>
                <input type="radio" name="paperOrientation" value="landscape">
                <span>Landscape</span>
            </label>
        </div>

        <h4>üìÑ Paper Size:</h4>
        <select id="paper-size-select">
          <option value="a4">A4 (210 x 297 mm)</option>
          <option value="us-letter">US Letter (8.5 x 11 in)</option>
          <option value="a5">A5 (148 x 210 mm)</option>
          <option value="a6">A6 (105 x 148 mm)</option>
        </select>

        <h4>üìê Custom Margins (mm):</h4>
        <div class="input-group-four">
            <input type="number" id="margin-top" min="0" value="0" placeholder="Top"> <input type="number" id="margin-bottom" min="0" value="0" placeholder="Bottom"> <input type="number" id="margin-left" min="0" value="0" placeholder="Left"> <input type="number" id="margin-right" min="0" value="0" placeholder="Right"> </div>

        <h4>üìè Division Size (mm):</h4>
        <div class="input-group">
            <input type="number" id="box-width" min="1" value="210" placeholder="Width (mm)" data-calculated="true"> <input type="number" id="box-height" min="1" value="297" placeholder="Height (mm)" data-calculated="true"> </div>

        <h4>‚¨áÔ∏è Gap Spacing (mm):</h4>
        <div class="input-group">
            <input type="number" id="row-gap-input" min="0" value="5" placeholder="Row Gap (Vertical)">
            <input type="number" id="col-gap-input" min="0" value="5" placeholder="Column Gap (Horizontal)">
        </div>

        <h4>‚¨ÜÔ∏è Upload Mode:</h4>
        <div id="upload-mode-controls" class="input-group-radio">
            <label data-mode="serial" data-division="1,2,4">
                <input type="radio" name="uploadMode" value="serial" checked>
                <span>Serial Wise (1, 2, 3...)</span>
            </label>
            <label data-mode="interleaved-A" data-division="2">
                <input type="radio" name="uploadMode" value="interleaved-A">
                <span>Interleaved (1, 3, 2, 4)</span>
            </label>
            <label data-mode="interleaved-standard" data-division="4">
                <input type="radio" name="uploadMode" value="interleaved-standard">
                <span>Standard Interleaved (1, 5, 2, 6)</span>
            </label>
             <label data-mode="interleaved-custom" data-division="4">
                <input type="radio" name="uploadMode" value="interleaved-custom">
                <span>Custom Interleaved (1, 6, 2, 5)</span>
            </label>
        </div>

        <h4>üì§ Upload Documents (PDF/DOC ready):</h4>
        <input id="multi-file-input" class="hidden-input" type="file" accept="image/*, .pdf" multiple>
        <button id="multi-upload-btn">‚ûï Choose Files (Images/PDF)</button>

        <h4>üíæ Save Sheets As Type:</h4> 
        <select id="save-as-type-select">
            <option value="pdf" selected>PDF Document (*.pdf)</option> 
            <option value="png">PNG Image (*.png)</option>
            <option value="jpg">JPEG Image (*.jpg)</option>
            <option value="doc">DOC Document (*.doc)</option>
            <option value="docx">DOCX Document (*.docx)</option>
        </select>

        <div id="save-quality-select-container">
            <h4>üöÄ Save Quality (Affects Speed):</h4> 
            <select id="save-quality-select">
                <option value="6.0">Ultimate Quality (6.0x - Slow)</option>
                <option value="4.0">High Quality (4.0x - Medium Speed)</option>
                <option value="2.5" selected>Fast Quality (2.5x - Fastest)</option> 
            </select>
        </div>

        <button id="save-sheets-btn" onclick="saveSheetsAsFile()">üíæ Start Save(2.5x) </button>  
        <p style="font-size:.85em; margin-top:10px;">*The speed is fast now. PDF save quality is limited by the **Screen/Preview Quality** setting above.*</p>

        <button id="print-btn" onclick="window.print()">üñ®Ô∏è Print All Sheets</button>
      </div>
    </div>
  </div>

  <div id="page-wrapper"></div>

  <ul id="context-menu">
      <li id="context-adjust" onclick="handleContextMenuAction('üí° Photo Adjust')">üí° Photo Adjust</li>
      <li id="context-replace" onclick="handleContextMenuAction('üîÑ Replace File')">üîÑ Replace File</li>
      <li id="context-crop" onclick="handleContextMenuAction('‚úÇÔ∏è Crop Option')">‚úÇÔ∏è Crop Option</li>
      <li onclick="deleteFile()">üóëÔ∏è Delete File</li>
  </ul>
  
  <div id="edit-modal">
      <div class="modal-content">
          <h3 id="modal-title">File Editor</h3>
          
          <div class="modal-main-area">
              <div class="modal-preview-container">
                  <div id="modal-preview"></div>

                  <div id="pdf-nav-controls" style="display:none; text-align:center; margin-top:8px;">
                    <button id="pdf-prev-btn">‚óÄ Prev</button>
                    <span id="pdf-page-indicator" style="margin:0 10px;">Page 1 / 1</span>
                    <button id="pdf-next-btn">Next ‚ñ∂</button>
                  </div>

                  <p style="font-size: 0.9em;">
                    **File:** <span id="modal-file-name">N/A</span> 
                    <br>
                    **Type:** <span id="modal-file-type">N/A</span>
                  </p>
              </div>

              <div class="modal-sidebar">
                  <p style="font-weight: bold; color: #ccc; margin-top: 0;">Available Actions:</p>
                  
                  <div id="adjust-controls" style="display:none;">
                      <label for="brightness-input">Brightness (%)</label>
                      <input type="number" id="brightness-input" min="50" max="200" value="100">
                      
                      <label for="contrast-input">Contrast (%)</label>
                      <input type="number" id="contrast-input" min="50" max="200" value="100">
                      
                      <button class="btn-adjust" onclick="applyImageAdjustments()">‚úÖ Apply Adjustments</button>
                      <button class="btn-adjust" onclick="resetImageAdjustments()">üîÑ Reset</button>
                      <p style="font-size: 0.7em; margin-top: 5px; color: #aaa;">(Only affects images, not PDFs.)</p>
                  </div>
                  
                  <div id="crop-controls" style="display:none;">
                      <label for="crop-width-input">Crop Width (px)</label>
                      <input type="number" id="crop-width-input" min="1" value="300">
                      
                      <label for="crop-height-input">Crop Height (px)</label>
                      <input type="number" id="crop-height-input" min="1" value="200">
                      
                      <button class="btn-crop" onclick="applyCrop()">‚úÖ Apply Crop</button>
                      <p style="font-size: 0.7em; margin-top: 5px; color: #aaa;">(Cropping is simulated by changing the box size.)</p>
                  </div>
                  
                  <div class="modal-actions">
                      <button class="btn-primary" id="modal-adjust-btn" onclick="openEditingModal('üí° Photo Adjust')">üí° Photo Adjust</button>
                      <button class="btn-replace" onclick="document.getElementById('modal-replace-input').click()">üîÑ Replace File</button>
                      <button class="btn-crop" id="modal-crop-btn" onclick="openEditingModal('‚úÇÔ∏è Crop Option')">‚úÇÔ∏è Crop Option</button>
                      <button class="btn-delete" onclick="deleteFileFromModal()">üóëÔ∏è Delete File</button>
                      
                      <input type="file" id="modal-replace-input" class="hidden-input" accept="image/*, .doc,.docx, .pdf" onchange="handleModalFileReplacement(event)">

                      <button class="btn-close" onclick="closeModal()">‚ùå Close Editor</button>
                  </div>
              </div>
          </div>
      </div>
  </div>

<script>
/* ---------- JS: Core Functions ---------- */

/* ---------- Constants & Globals ---------- */
const PAPER_SIZES = { 'a4': { w:210, h:297 }, 'us-letter': { w:215.9, h:279.4 }, 'a5': { w:148, h:210 }, 'a6': { w:105, h:148 } };
const DIVISION_LAYOUTS = { '1': { cols: 1, rows: 1, boxesPerPage: 1 }, '2': { cols: 1, rows: 2, boxesPerPage: 2 }, '4': { cols: 2, rows: 2, boxesPerPage: 4 } };

let marginTop = 0, marginBottom = 0, marginLeft = 0, marginRight = 0; 
let currentPaperSize = 'a4', currentBoxWidth = 0, currentBoxHeight = 0, currentColGap = 0, currentRowGap = 0;
let isCustomSize = false;
let currentDivision = '1'; 
let currentOrientation = 'portrait';
let currentLayout = DIVISION_LAYOUTS['1']; 
let currentPageIndex = 0, nextDivisionNumber = 1;
let activeBoxElement = null;
let uploadMode = 'serial', currentInterleavedFileIndex = 0;
let boxFileMap = new Map();
let currentModalAction = '';

let modalPdfObj = null, modalPdfPageNum = 1, modalPdfTotalPages = 1, modalPdfCurrentBoxId = null;

function isPdfPageEntry(obj) {
    return obj && obj.kind === 'pdfpage' && typeof obj.pdfId === 'number' && typeof obj.pageNumber === 'number'; // Check for pdfId instead of pdf object
}

/* ---------- Context Menu & Modal handlers (kept as original) ---------- */
function hideContextMenu() {
    document.getElementById('context-menu').style.display = 'none';
    document.removeEventListener('click', hideContextMenuOnOutsideClick);
}
function hideContextMenuOnOutsideClick(e) {
    const menu = document.getElementById('context-menu');
    if (!menu.contains(e.target) && e.target !== activeBoxElement && !menu.contains(e.target)) {
        hideContextMenu();
    }
}
function showContextMenu(boxElement, x, y) {
    hideContextMenu();
    activeBoxElement = boxElement;
    const entry = boxFileMap.get(parseInt(boxElement.id.split('-')[2]));
    const isPDF = isPdfPageEntry(entry);
    document.getElementById('context-adjust').style.display = isPDF ? 'none' : 'list-item';
    document.getElementById('context-crop').style.display = isPDF ? 'none' : 'list-item';
    const contextMenu = document.getElementById('context-menu');
    contextMenu.style.left = `${Math.min(x, window.innerWidth - 170)}px`;
    contextMenu.style.top = `${Math.min(y, window.innerHeight - contextMenu.offsetHeight - 10)}px`;
    contextMenu.style.display = 'block';
    setTimeout(() => { document.addEventListener('click', hideContextMenuOnOutsideClick); }, 10);
}
window.handleContextMenuAction = function(action) {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) {
        if (action !== 'üóëÔ∏è Delete File') {
            alert("No file in this box to edit.");
            hideContextMenu();
            return;
        }
    }
    if (action === 'üóëÔ∏è Delete File') deleteFile();
    else openEditingModal(action);
}

function openEditingModal(action) {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) {
        alert("No file found in this box to edit. Upload a file first.");
        hideContextMenu();
        return;
    }
    const divisionNumber = parseInt(activeBoxElement.id.split('-')[2]);
    const entry = boxFileMap.get(divisionNumber);
    currentModalAction = action;
    const isPDF = isPdfPageEntry(entry);

    document.getElementById('adjust-controls').style.display = (!isPDF && action === 'üí° Photo Adjust') ? 'block' : 'none';
    document.getElementById('crop-controls').style.display = (!isPDF && action === '‚úÇÔ∏è Crop Option') ? 'block' : 'none';

    document.getElementById('modal-adjust-btn').disabled = isPDF;
    document.getElementById('modal-crop-btn').disabled = isPDF;
    document.getElementById('modal-adjust-btn').style.opacity = isPDF ? 0.5 : 1;
    document.getElementById('modal-crop-btn').style.opacity = isPDF ? 0.5 : 1;

    document.getElementById('modal-title').textContent = `${action} View for Box ${divisionNumber}`;
    document.getElementById('modal-file-name').textContent = activeBoxElement.dataset.fileName;
    document.getElementById('modal-file-type').textContent = isPDF ? 'application/pdf (page preview)' : (entry && entry.type ? entry.type : 'Unknown/Placeholder');

    const preview = document.getElementById('modal-preview');
    preview.innerHTML = '';

    modalPdfObj = null; modalPdfPageNum = 1; modalPdfTotalPages = 1; modalPdfCurrentBoxId = null;
    document.getElementById('pdf-nav-controls').style.display = 'none';

    if (isPdfPageEntry(entry)) {
        // Retrieve PDF object from the global map
        const pdfDoc = loadedPDFs.get(entry.pdfId);
        if (pdfDoc) {
            modalPdfObj = pdfDoc;
            modalPdfTotalPages = modalPdfObj.numPages;
            modalPdfPageNum = entry.pageNumber;
            modalPdfCurrentBoxId = divisionNumber;
            document.getElementById('pdf-nav-controls').style.display = 'block';
            document.getElementById('pdf-page-indicator').textContent = `Page ${modalPdfPageNum} / ${modalPdfTotalPages}`;
            // Use CURRENT_RENDER_SCALE for modal preview
            renderPdfPageInModal(modalPdfObj, modalPdfPageNum, preview);
        } else {
             preview.innerHTML = `<span style="color:#ccc">Error: PDF document not found in cache.</span>`;
        }
    } else if (entry && entry.type && entry.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function(ev) {
            const img = document.createElement('img');
            img.src = ev.target.result;
            img.alt = activeBoxElement.dataset.fileName;
            img.style.filter = activeBoxElement.dataset.filter || 'none';
            preview.appendChild(img);

            const currentBrightness = activeBoxElement.dataset.brightness || '100';
            const currentContrast = activeBoxElement.dataset.contrast || '100';
            document.getElementById('brightness-input').value = currentBrightness;
            document.getElementById('contrast-input').value = currentContrast;

            const currentCropWidth = activeBoxElement.dataset.cropWidth || activeBoxElement.clientWidth;
            const currentCropHeight = activeBoxElement.dataset.cropHeight || activeBoxElement.clientHeight;
            document.getElementById('crop-width-input').value = currentCropWidth;
            document.getElementById('crop-height-input').value = currentCropHeight;
            updateModalPreviewImageCrop();
        };
        reader.readAsDataURL(entry);
    } else {
        preview.innerHTML = `<span style="color:#ccc">Cannot render preview for this item.</span>`;
    }

    document.getElementById('edit-modal').style.display = 'flex';
    document.getElementById('edit-modal').classList.add('active');
    hideContextMenu();
}

/* ---------- Render PDF page in modal ---------- */
function renderPdfPageInModal(pdf, pageNum, previewContainer) {
    previewContainer.innerHTML = '';
    // Add loading indicator
    previewContainer.innerHTML = '<span style="color:#f39c12; font-size: 1.2em;">Loading PDF Page...</span>';
    
    pdf.getPage(pageNum).then(page => {
        const previewContainerWidth = Math.min(previewContainer.clientWidth || 800, 900);
        const pageViewport1 = page.getViewport({ scale: 1 });

        const baseScaleToFit = previewContainerWidth / pageViewport1.width;
        // OPTIMIZATION: Use CURRENT_RENDER_SCALE for modal rendering
        const finalScale = baseScaleToFit * CURRENT_RENDER_SCALE;
        const viewport = page.getViewport({ scale: finalScale });

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);
        canvas.style.width = '100%';
        canvas.style.height = '100%';

        previewContainer.innerHTML = ''; // Clear loading indicator

        const renderContext = { canvasContext: ctx, viewport: viewport };
        page.render(renderContext).promise.then(() => {
            previewContainer.appendChild(canvas);
            document.getElementById('pdf-page-indicator').textContent = `Page ${modalPdfPageNum} / ${modalPdfTotalPages}`;
        }).catch(err => {
            previewContainer.innerHTML = `<div style="color:#ccc">Error rendering PDF page: ${err.message}</div>`;
        });
    }).catch(err => {
        previewContainer.innerHTML = `<div style="color:#ccc">Error loading PDF page: ${err.message}</div>`;
    });
}
document.getElementById('pdf-prev-btn')?.addEventListener('click', () => {
    if (!modalPdfObj) return;
    if (modalPdfPageNum > 1) {
        modalPdfPageNum--;
        // Update the boxFileMap entry for the currently open box
        if (modalPdfCurrentBoxId && isPdfPageEntry(boxFileMap.get(modalPdfCurrentBoxId))) {
            const entry = boxFileMap.get(modalPdfCurrentBoxId);
            entry.pageNumber = modalPdfPageNum;
            boxFileMap.set(modalPdfCurrentBoxId, entry);
            renderFileInBox(document.getElementById(`box-div-${modalPdfCurrentBoxId}`), entry); // Re-render the box on the sheet
        }
        renderPdfPageInModal(modalPdfObj, modalPdfPageNum, document.getElementById('modal-preview'));
    }
});
document.getElementById('pdf-next-btn')?.addEventListener('click', () => {
    if (!modalPdfObj) return;
    if (modalPdfPageNum < modalPdfTotalPages) {
        modalPdfPageNum++;
        // Update the boxFileMap entry for the currently open box
        if (modalPdfCurrentBoxId && isPdfPageEntry(boxFileMap.get(modalPdfCurrentBoxId))) {
            const entry = boxFileMap.get(modalPdfCurrentBoxId);
            entry.pageNumber = modalPdfPageNum;
            boxFileMap.set(modalPdfCurrentBoxId, entry);
            renderFileInBox(document.getElementById(`box-div-${modalPdfCurrentBoxId}`), entry); // Re-render the box on the sheet
        }
        renderPdfPageInModal(modalPdfObj, modalPdfPageNum, document.getElementById('modal-preview'));
    }
});

/* ---------- Image adjustment helpers (kept as original) ---------- */
function updateModalPreviewImageFilter() {
    const preview = document.getElementById('modal-preview');
    const img = preview.querySelector('img');
    if (img) {
        const brightness = document.getElementById('brightness-input').value;
        const contrast = document.getElementById('contrast-input').value;
        const filterStyle = `brightness(${brightness}%) contrast(${contrast}%)`;
        img.style.filter = filterStyle;
    }
}
function updateModalPreviewImageCrop() {
    const preview = document.getElementById('modal-preview');
    const width = Number(document.getElementById('crop-width-input').value);
    const height = Number(document.getElementById('crop-height-input').value);
    preview.style.width = 'auto';
    preview.style.height = 'auto';
    preview.style.maxWidth = '100%';
    if (currentModalAction === '‚úÇÔ∏è Crop Option') {
         preview.style.width = `${width}px`;
         preview.style.height = `${height}px`;
         preview.style.maxWidth = '100%';
    }
}

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('brightness-input')?.addEventListener('input', updateModalPreviewImageFilter);
    document.getElementById('contrast-input')?.addEventListener('input', updateModalPreviewImageFilter);
    document.getElementById('crop-width-input')?.addEventListener('input', updateModalPreviewImageCrop);
    document.getElementById('crop-height-input')?.addEventListener('input', updateModalPreviewImageCrop);
});

window.applyImageAdjustments = function() {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) return;
    const entry = boxFileMap.get(parseInt(activeBoxElement.id.split('-')[2]));
    if (isPdfPageEntry(entry)) return;
    const brightness = document.getElementById('brightness-input').value;
    const contrast = document.getElementById('contrast-input').value;
    const filterStyle = `brightness(${brightness}%) contrast(${contrast}%)`;
    updateModalPreviewImageFilter();
    const boxImg = activeBoxElement.querySelector('img');
    if (boxImg) boxImg.style.filter = filterStyle;
    activeBoxElement.dataset.brightness = brightness;
    activeBoxElement.dataset.contrast = contrast;
    activeBoxElement.dataset.filter = filterStyle;
}
window.resetImageAdjustments = function() {
    document.getElementById('brightness-input').value = '100';
    document.getElementById('contrast-input').value = '100';
    updateModalPreviewImageFilter();
    if (activeBoxElement) {
        const boxImg = activeBoxElement.querySelector('img');
        if (boxImg) boxImg.style.filter = 'none';
        delete activeBoxElement.dataset.brightness;
        delete activeBoxElement.dataset.contrast;
        delete activeBoxElement.dataset.filter;
    }
}

window.applyCrop = function() {
    if (!activeBoxElement || !activeBoxElement.dataset.fileName) return;
    const entry = boxFileMap.get(parseInt(activeBoxElement.id.split('-')[2]));
    if (isPdfPageEntry(entry)) return;
    const cropWidth = document.getElementById('crop-width-input').value;
    const cropHeight = document.getElementById('crop-height-input').value;
    updateModalPreviewImageCrop();
    activeBoxElement.style.width = `${cropWidth}px`;
    activeBoxElement.style.height = `${cropHeight}px`;
    activeBoxElement.style.flexShrink = '0';
    activeBoxElement.dataset.cropWidth = cropWidth;
    activeBoxElement.dataset.cropHeight = cropHeight;
}

window.closeModal = function() {
    document.getElementById('edit-modal').classList.remove('active');
    const preview = document.getElementById('modal-preview');
    preview.style.width = 'auto';
    preview.style.height = 'auto';
    setTimeout(() => {
        document.getElementById('edit-modal').style.display = 'none';
        activeBoxElement = null;
        currentModalAction = '';
        modalPdfObj = null;
        modalPdfPageNum = 1;
        modalPdfTotalPages = 1;
        modalPdfCurrentBoxId = null;
    }, 300);
}

/* ---------- Replace, delete & render functions (kept as original, slight defensive fixes) ---------- */
function handleModalFileReplacement(e) {
    const file = e.target.files[0];
    if (!file || !activeBoxElement) return;
    const divisionNumber = parseInt(activeBoxElement.id.split('-')[2]);
    if (file.type === 'application/pdf') {
        // Handle PDF replacement with an alert to confirm the action
        if (confirm(`Replacing a single box with a PDF will fill subsequent boxes starting at Box ${divisionNumber}. Continue?`)) {
            placePdfFileStartingAtBox(file, divisionNumber);
            e.target.value = null;
            closeModal();
        } else {
            e.target.value = null;
        }
        return;
    }
    boxFileMap.set(divisionNumber, file);
    activeBoxElement.dataset.fileName = file.name;

    renderFileInBox(activeBoxElement, file).then(() => {
        openEditingModal('üîÑ Replace File');
        e.target.value = null;
    }).catch(() => {
        boxFileMap.delete(divisionNumber);
        delete activeBoxElement.dataset.fileName;
        alert(`Failed to replace file with ${file.name}.`);
        closeModal();
    });
}

window.deleteFileFromModal = function() { 
    if (!activeBoxElement) return;
    deleteFileFromBox(activeBoxElement);
    closeModal();
}

/* ---------- Render files (images & PDFs) ---------- */
async function renderFileInBox(boxElement, fileOrEntry) {
    return new Promise((resolve, reject) => {
        boxElement.innerHTML = '';
        const emptyClasses = ['color-a','color-b','color-c','color-d'];
        boxElement.classList.remove('empty-state', ...emptyClasses);
        boxElement.classList.add('filled-state');
        boxElement.style.backgroundImage = 'none';
        boxElement.style.position = 'relative';

        if (boxElement.dataset.cropWidth && boxElement.dataset.cropHeight) {
            boxElement.style.width = `${boxElement.dataset.cropWidth}px`;
            boxElement.style.height = `${boxElement.dataset.cropHeight}px`;
            boxElement.style.flexShrink = '0';
        } else {
            boxElement.style.width = '';
            boxElement.style.height = '';
            boxElement.style.flexShrink = '';
        }

        const fileNameSpan = document.createElement('span');
        fileNameSpan.classList.add('file-name-overlay'); 
        fileNameSpan.style.cssText = 'position:absolute; bottom:2px; right:2px; background:rgba(0,0,0,0.5); color:white; padding:1px 4px; font-size:8px; z-index:10;';

        if (isPdfPageEntry(fileOrEntry)) {
            // Retrieve PDF object from the global map
            const pdf = loadedPDFs.get(fileOrEntry.pdfId);
            const pageNum = fileOrEntry.pageNumber;
            fileNameSpan.textContent = fileOrEntry.name || (`PDF page ${pageNum}`);
            boxElement.innerHTML = '<span style="color:#f39c12; font-size: 0.9em;">Loading PDF Page...</span>';

            if (!pdf) {
                boxElement.innerHTML = `<span>Error: PDF ID ${fileOrEntry.pdfId} missing.</span>`;
                reject(new Error(`PDF document not found for ID: ${fileOrEntry.pdfId}`));
                return;
            }

            // Use CURRENT_RENDER_SCALE for screen rendering
            const finalScaleFactor = CURRENT_RENDER_SCALE; 

            pdf.getPage(pageNum).then(page => {
                const pageViewport1 = page.getViewport({ scale: 1 });
                const boxWidthPx = Math.max(10, boxElement.clientWidth || 200);
                const baseScaleToFit = boxWidthPx / pageViewport1.width;
                const finalScale = baseScaleToFit * finalScaleFactor;

                const viewport = page.getViewport({ scale: finalScale });

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                canvas.width = Math.round(viewport.width);
                canvas.height = Math.round(viewport.height);

                canvas.style.width = '100%';
                canvas.style.height = '100%';

                boxElement.innerHTML = ''; // Clear loading indicator

                const renderContext = { canvasContext: context, viewport: viewport };
                page.render(renderContext).promise.then(() => {
                    boxElement.appendChild(canvas);
                    boxElement.appendChild(fileNameSpan);
                    resolve();
                }).catch(err => {
                    boxElement.innerHTML = `<span>Error rendering PDF page: ${err.message}</span>`;
                    reject(err);
                });
            }).catch(err => {
                boxElement.innerHTML = `<span>Error getting PDF page: ${err.message}</span>`;
                reject(err);
            });
            return;
        }

        const file = fileOrEntry;
        if (file && file.type && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = document.createElement('img');
                img.src = event.target.result;
                img.alt = file.name || 'image';
                img.style.filter = boxElement.dataset.filter || 'none';
                fileNameSpan.textContent = file.name || 'image';
                boxElement.appendChild(img);
                boxElement.appendChild(fileNameSpan);
                resolve();
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
            return;
        }

        fileNameSpan.textContent = fileOrEntry.name || 'Unsupported';
        boxElement.innerHTML = `<span>File: ${fileOrEntry.name || 'Unsupported Preview'}</span>`;
        boxElement.appendChild(fileNameSpan);
        resolve();
    });
}

/* ---------- Drag & Drop and Box interactions (kept as original) ---------- */
function handleDragOver(e) { e.preventDefault(); if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) e.currentTarget.style.border = '2px solid blue'; }
function handleDragLeave(e) { e.currentTarget.style.border = '1px dashed #ccc'; }
function handleDrop(e) {
    e.preventDefault();
    handleDragLeave(e);
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
        const file = files[0];
        const boxElement = e.currentTarget;
        const divisionNumber = parseInt(boxElement.id.split('-')[2]);
        if (file.type === 'application/pdf') {
            placePdfFileStartingAtBox(file, divisionNumber);
        } else if (file.type.startsWith('image/')) {
            boxFileMap.set(divisionNumber, file);
            boxElement.dataset.fileName = file.name;

            renderFileInBox(boxElement, file).catch(err => {
                console.error(err);
                boxFileMap.delete(divisionNumber);
                delete boxElement.dataset.fileName;
            });
        } else {
            alert('Unsupported file type.');
        }
    }
}
function handleBoxClick(e) {
    const box = e.currentTarget;
    if (e.button === 2) { e.preventDefault(); if (box.dataset.fileName) showContextMenu(box, e.clientX, e.clientY); return; }
    if (e.button === 0 && box.dataset.fileName) { activeBoxElement = box; openEditingModal('üí° Photo Adjust'); }
}

/* ---------- Page & Grid functions (kept as original) ---------- */
function calculateConstrainedBoxSize(paperSizeKey = currentPaperSize) {
    const boxWInput = document.getElementById('box-width');
    const boxHInput = document.getElementById('box-height');
    if (isCustomSize) {
        boxWInput.value = currentBoxWidth.toFixed(1);
        boxHInput.value = currentBoxHeight.toFixed(1);
        boxWInput.removeAttribute('data-calculated');
        boxHInput.removeAttribute('data-calculated');
        return;
    }
    const size = PAPER_SIZES[paperSizeKey];
    let printableWidth = size.w;
    let printableHeight = size.h;

    if (currentOrientation === 'landscape') {
        printableWidth = size.h;
        printableHeight = size.w;
    }

    const totalHorizontalMargin = marginLeft + marginRight;
    const totalVerticalMargin = marginTop + marginBottom;
    printableWidth -= totalHorizontalMargin;
    printableHeight -= totalVerticalMargin;

    let newWidth = (printableWidth - (currentLayout.cols - 1) * currentColGap) / currentLayout.cols;
    let newHeight = (printableHeight - (currentLayout.rows - 1) * currentRowGap) / currentLayout.rows;
    currentBoxWidth = Math.max(1, newWidth);
    currentBoxHeight = Math.max(1, newHeight);
    boxWInput.value = currentBoxWidth.toFixed(1);
    boxHInput.value = currentBoxHeight.toFixed(1);
    boxWInput.setAttribute('data-calculated','true');
    boxHInput.setAttribute('data-calculated','true');

    document.getElementById('add-page-btn').textContent = `‚ûï Add Empty Page (${currentLayout.boxesPerPage} Divisions)`;
}
function applyGridStyles(container) {
    container.style.padding = `${marginTop}mm ${marginRight}mm ${marginBottom}mm ${marginLeft}mm`;
    container.style.gridTemplateColumns = `repeat(${currentLayout.cols}, ${currentBoxWidth}mm)`;
    container.style.gridTemplateRows = `repeat(${currentLayout.rows}, ${currentBoxHeight}mm)`;
    container.style.gridColumnGap = `${currentColGap}mm`;
    container.style.gridRowGap = `${currentRowGap}mm`;
}
function createPage(pageIndex){
  const wrapper = document.getElementById('page-wrapper');
  const pageDiv = document.createElement('div');
  pageDiv.classList.add(`${currentPaperSize}-page`, 'paper');
  pageDiv.id = `page-${pageIndex}`;
  if (currentOrientation === 'landscape') pageDiv.classList.add('landscape');
  if (document.getElementById('togglePaperBtn').textContent === 'Show Screen Paper') pageDiv.classList.add('hidden');

  const gridContainer = document.createElement('div');
  gridContainer.classList.add('grid-container');
  applyGridStyles(gridContainer);

  const colorClasses = ['color-a','color-b','color-c','color-d'];
  for (let i=0;i<currentLayout.boxesPerPage;i++){
      const box = document.createElement('div');
      box.classList.add('box');
      box.id = `box-div-${nextDivisionNumber}`;
      box.innerHTML = `<span>Page ${nextDivisionNumber}</span>`;
      const colorIndex = (nextDivisionNumber - 1) % colorClasses.length;
      box.classList.add('empty-state', colorClasses[colorIndex]);
      box.addEventListener('dragover', handleDragOver);
      box.addEventListener('dragleave', handleDragLeave);
      box.addEventListener('drop', handleDrop);
      box.addEventListener('click', handleBoxClick);
      box.addEventListener('contextmenu', handleBoxClick);
      
      // Re-render existing content if available
      if (boxFileMap.has(nextDivisionNumber)) {
          const file = boxFileMap.get(nextDivisionNumber);
          box.dataset.fileName = file.name || (file.origName ? file.origName + ` (p${file.pageNumber})` : `Box ${nextDivisionNumber}`);
          box.classList.remove('empty-state', colorClasses[colorIndex]);
          box.classList.add('filled-state');
          // No need to wait for rendering here, it will be done asynchronously
          renderFileInBox(box, file).catch(err => console.error('Initial render error:', err)); 
      }
      
      gridContainer.appendChild(box);
      nextDivisionNumber++;
  }
  pageDiv.appendChild(gridContainer);
  wrapper.appendChild(pageDiv);
}

window.resetPaper = function(){
  const wrapper = document.getElementById('page-wrapper');
  wrapper.innerHTML = '';
  const tempBoxFileMap = new Map(boxFileMap);
  const totalDivisions = nextDivisionNumber - 1;
  currentPageIndex = 0;
  nextDivisionNumber = 1;
  currentInterleavedFileIndex = 0;
  boxFileMap.clear();
  calculateConstrainedBoxSize();
  const totalPagesNeeded = Math.ceil(totalDivisions / currentLayout.boxesPerPage);
  const numPagesToCreate = Math.max(2, totalPagesNeeded);
  for (let i=0;i<numPagesToCreate;i++) createPage(i);
  boxFileMap = tempBoxFileMap;
  const renderPromises = [];
  for (const [divisionNumber,file] of boxFileMap.entries()){
      const box = document.getElementById(`box-div-${divisionNumber}`);
      if (box) {
          const colorClasses = ['color-a','color-b','color-c','color-d'];
          const colorIndex = (divisionNumber - 1) % colorClasses.length;
          box.classList.remove('empty-state', colorClasses[colorIndex]);
          box.classList.add('filled-state');
          box.dataset.fileName = file.name || (file.origName ? file.origName + ` (p${file.pageNumber})` : `Box ${divisionNumber}`);
          renderPromises.push(renderFileInBox(box, file).catch(() => {})); // Push promise, ignore errors to continue loading
      }
  }
  Promise.all(renderPromises).then(hideContextMenu).catch(()=>hideContextMenu());
};

window.updateMargins = function() {
    marginTop = parseFloat(document.getElementById('margin-top').value) || 0;
    marginBottom = parseFloat(document.getElementById('margin-bottom').value) || 0;
    marginLeft = parseFloat(document.getElementById('margin-left').value) || 0;
    marginRight = parseFloat(document.getElementById('margin-right').value) || 0;
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    resetPaper();
};

window.updateDivisionSize = function() {
    currentBoxWidth = parseFloat(document.getElementById('box-width').value) || 1;
    currentBoxHeight = parseFloat(document.getElementById('box-height').value) || 1;
    if (currentBoxWidth < 1 || currentBoxHeight < 1) return;
    isCustomSize = true;
    document.getElementById('box-width').removeAttribute('data-calculated');
    document.getElementById('box-height').removeAttribute('data-calculated');
    resetPaper();
};

window.updateGapSizes = function() {
    currentColGap = parseFloat(document.getElementById('col-gap-input').value) || 0;
    currentRowGap = parseFloat(document.getElementById('row-gap-input').value) || 0;
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    resetPaper();
};

function handlePaperSizeChange(newSize) {
    currentPaperSize = newSize;
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    resetPaper();
}
function handleDivisionChange(newDivision) {
    currentDivision = newDivision;
    currentLayout = DIVISION_LAYOUTS[newDivision];
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    updateUploadModes(newDivision);
    resetPaper();
}
function handleOrientationChange(newOrientation) {
    currentOrientation = newOrientation;
    isCustomSize = false;
    document.getElementById('box-width').setAttribute('data-calculated','true');
    document.getElementById('box-height').setAttribute('data-calculated','true');
    resetPaper();
}

function updateUploadModes(division) {
    const allModes = document.querySelectorAll('#upload-mode-controls label');
    let serialChecked = false;

    allModes.forEach(label => {
        const supportedDivisions = label.dataset.division.split(',');
        const isSupported = supportedDivisions.includes(division);
        label.style.display = isSupported ? 'flex' : 'none';

        if (isSupported) {
            const radio = label.querySelector('input[type="radio"]');
            if (radio.value === uploadMode) {
                radio.checked = true;
                serialChecked = true;
            } else if (radio.value === 'serial' && !serialChecked) {
                radio.checked = true;
                uploadMode = 'serial';
                serialChecked = true;
            }
        }
    });

    const currentModeSupported = document.querySelector(`#upload-mode-controls input[value="${uploadMode}"]`)?.closest('label')?.style.display === 'flex';
    if (!currentModeSupported) {
        document.querySelector(`#upload-mode-controls input[value="serial"]`).checked = true;
        uploadMode = 'serial';
    }
}

window.addNewPage = function() {
    currentPageIndex++;
    createPage(currentPageIndex);
    const newPage = document.getElementById(`page-${currentPageIndex}`);
    if (newPage && document.getElementById('togglePaperBtn').textContent === 'Show Screen Paper') newPage.classList.add('hidden');
}

/* ---------- Upload Mode logic (kept as original) ---------- */
function getNextSerialBoxID() {
    for (let i=1;i<nextDivisionNumber;i++){
        const box = document.getElementById(`box-div-${i}`);
        if (box && !boxFileMap.has(i)) return i;
    }
    return nextDivisionNumber;
}

function getInterleavedID(mode) {
    currentInterleavedFileIndex++;
    const BPP = currentLayout.boxesPerPage;
    const F = currentInterleavedFileIndex;
    let targetID;

    if (currentDivision === '4') {
        const block = 2 * BPP;
        const blockIndex = Math.floor((F - 1) / block);
        const blockBaseID = blockIndex * block + 1;
        const F_g = F - (blockIndex * block);

        if (F_g % 2 === 1) {
            targetID = blockBaseID + (F_g + 1)/2 - 1;
        } else {
            const B_on_page = F_g / 2;
            if (mode === 'interleaved-standard') {
                const pageTwoBase = blockBaseID + BPP;
                targetID = pageTwoBase + B_on_page - 1;
            } else if (mode === 'interleaved-custom') {
                const PAGE_TWO_CUSTOM_ORDER_OFFSET = [6,5,8,7];
                const boxIDInBlock = PAGE_TWO_CUSTOM_ORDER_OFFSET[B_on_page - 1];
                targetID = blockBaseID + boxIDInBlock - 1;
            }
        }
        return targetID;
    } else if (currentDivision === '2' && mode === 'interleaved-A') {
        const blockCycle = F % 4;
        const cycleBase = F - (blockCycle || 4);
        if (blockCycle === 1) targetID = cycleBase + 1;
        else if (blockCycle === 2) targetID = cycleBase + 3;
        else if (blockCycle === 3) targetID = cycleBase + 2;
        else if (blockCycle === 0) targetID = cycleBase + 4;
        return targetID;
    }

    return getNextSerialBoxID();
}

function getNextTargetBoxID() {
    if (currentDivision === '1') {
        uploadMode = 'serial';
        document.querySelector(`#upload-mode-controls input[value="serial"]`).checked = true;
    }

    if (uploadMode === 'serial') {
        currentInterleavedFileIndex = 0;
        return getNextSerialBoxID();
    } else {
        let filledCount = 0;
        for (let i = 1; i < nextDivisionNumber; i++) {
            if (boxFileMap.has(i)) filledCount++;
        }
        currentInterleavedFileIndex = filledCount;
        return getInterleavedID(uploadMode);
    }
}

function checkAndCreatePages(requiredID) {
  while (requiredID >= nextDivisionNumber) {
      currentPageIndex++;
      createPage(currentPageIndex);
      const newPage = document.getElementById(`page-${currentPageIndex}`);
      if (newPage && document.getElementById('togglePaperBtn').textContent === 'Show Screen Paper') newPage.classList.add('hidden');
  }
}

/* ---------- File upload handlers (OPTIMIZED FOR PDF SPEED) ---------- */
function handleMultiPhotoUpload(files){
    if (!files || files.length === 0) return;
    Array.from(files).forEach(f => {
        if (f.type === 'application/pdf') handlePdfFile(f);
        else if (f.type.startsWith('image/')) handleFile(f);
        else alert(`File ${f.name} skipped: Only Images and PDFs are supported.`);
    });
}

function handleFile(file) {
    const targetID = getNextTargetBoxID();

    if (uploadMode !== 'serial' && boxFileMap.has(targetID)) {
        alert(`File ${file.name} skipped: The next calculated slot (Box ${targetID}) is already filled. Use Serial mode or delete existing content.`);
        currentInterleavedFileIndex--;
        return;
    }

    checkAndCreatePages(targetID);
    const box = document.getElementById(`box-div-${targetID}`);
    if (box) {
        boxFileMap.set(targetID, file);
        box.dataset.fileName = file.name;

        renderFileInBox(box, file).catch(error => {
            console.error(`Error rendering file ${file.name} in box ${targetID}:`, error);
            alert(`Could not display ${file.name}. Check console for details.`);
            box.innerHTML = `<span>Error: ${file.name}</span>`;
            boxFileMap.delete(targetID);
            delete box.dataset.fileName;
            if (uploadMode !== 'serial') currentInterleavedFileIndex--;
        });
    }
}

function handlePdfFile(file) {
    const reader = new FileReader();
    reader.onload = function(ev) {
        const arrayBuffer = ev.target.result;
        
        // 1. Get a unique ID for this PDF
        const pdfId = nextPdfId++;
        
        // 2. Start loading the PDF document (this is asynchronous)
        pdfjsLib.getDocument({ data: arrayBuffer }).promise.then(pdfDoc => {
            // 3. Store the loaded PDF document in the global map for later use
            loadedPDFs.set(pdfId, pdfDoc);
            const total = pdfDoc.numPages;

            // 4. ***OPTIMIZATION: Synchronously map pages to boxes for instant upload speed***
            for (let p = 1; p <= total; p++) {
                const targetID = getNextTargetBoxID();
                if (uploadMode !== 'serial' && boxFileMap.has(targetID)) {
                    currentInterleavedFileIndex--;
                    continue;
                }
                checkAndCreatePages(targetID);
                const box = document.getElementById(`box-div-${targetID}`);
                if (!box) continue;
                
                // Store only the PDF ID and page number in the boxFileMap
                const entry = {
                    kind: 'pdfpage',
                    pdfId: pdfId, // Store ID instead of object
                    pageNumber: p,
                    name: `${file.name} (p${p})`,
                    origName: file.name
                };
                boxFileMap.set(targetID, entry);
                box.dataset.fileName = entry.name;
                
                // 5. Render asynchronously - this part is the only one that takes time, but the map is updated instantly.
                // We don't wait for the render.
                renderFileInBox(box, entry).catch(err => console.error('PDF page render error:', err));
            }
        }).catch(err => {
            alert('Failed to parse PDF: ' + err.message);
            console.error(err);
        });
        
        document.getElementById('multi-upload-btn').textContent = `...Loading PDF ${file.name}...`;

    };
    reader.onerror = function(err) {
        alert('Failed to read PDF file.');
        console.error(err);
    };
    reader.readAsArrayBuffer(file);
}

function placePdfFileStartingAtBox(file, startBoxId) {
    const reader = new FileReader();
    reader.onload = function(ev) {
        const arrayBuffer = ev.target.result;
        const pdfId = nextPdfId++;
        
        pdfjsLib.getDocument({ data: arrayBuffer }).promise.then(pdfDoc => {
            loadedPDFs.set(pdfId, pdfDoc);
            let pointer = startBoxId;
            const total = pdfDoc.numPages;

            // 1. Delete existing files from startBoxId onwards
            for(let i=startBoxId; i < nextDivisionNumber; i++){
                const existingBox = document.getElementById(`box-div-${i}`);
                if(existingBox && boxFileMap.has(i)) deleteFileFromBox(existingBox);
            }

            // 2. Synchronously map new PDF pages
            for (let p = 1; p <= total; p++) {
                checkAndCreatePages(pointer);
                const box = document.getElementById(`box-div-${pointer}`);
                if (!box) { pointer++; continue; }
                const entry = {
                    kind: 'pdfpage',
                    pdfId: pdfId, // Store ID instead of object
                    pageNumber: p,
                    name: `${file.name} (p${p})`,
                    origName: file.name
                };
                boxFileMap.set(pointer, entry);
                box.dataset.fileName = entry.name;
                // Render asynchronously
                renderFileInBox(box, entry).catch(err => console.error('PDF page render error:', err));
                pointer++;
            }
        }).catch(err => {
            alert('Failed to parse PDF: ' + err.message);
            console.error(err);
        });
    };
    reader.readAsArrayBuffer(file);
}

function deleteFileFromBox(boxElement) {
    const divisionNumber = parseInt(boxElement.id.split('-')[2]);
    const colorClasses = ['color-a','color-b','color-c','color-d'];
    const colorIndex = (divisionNumber - 1) % colorClasses.length;
    boxElement.classList.remove('filled-state');
    boxElement.classList.add('empty-state', colorClasses[colorIndex]);
    boxElement.innerHTML = `<span>Page ${divisionNumber}</span>`;
    boxElement.style.backgroundImage = 'none';
    delete boxElement.dataset.fileName;
    delete boxElement.dataset.brightness;
    delete boxElement.dataset.contrast;
    delete boxElement.dataset.filter;
    delete boxElement.dataset.cropWidth;
    delete boxElement.dataset.cropHeight;
    boxElement.style.width = '';
    boxElement.style.height = '';
    boxElement.style.flexShrink = '';
    boxFileMap.delete(divisionNumber);
    // Note: We intentionally DO NOT delete the PDF object from loadedPDFs 
    // unless ALL of its pages are deleted, to allow for faster re-upload/replacement.
}
window.deleteFile = function() {
    if (activeBoxElement) {
        deleteFileFromBox(activeBoxElement);
        hideContextMenu();
    }
}

/* ---------- Save As File Function (OPTIMIZED FOR SPEED) ---------- */
window.saveSheetsAsFile = async function() {
    const saveType = document.getElementById('save-as-type-select').value;
    const saveQualitySelect = document.getElementById('save-quality-select');
    const paperWrapper = document.getElementById('page-wrapper');
    const controlsContainer = document.getElementById('controls-panel-container');
    const saveBtn = document.getElementById('save-sheets-btn');
    // NOTE: The CAPTURE_SCALE is now only used for image quality setting in html2canvas,
    // but we trust the existing PDF canvas resolution set by CURRENT_RENDER_SCALE for speed.
    const selectedQualityScale = saveQualitySelect.value;
    const CAPTURE_SCALE = parseFloat(selectedQualityScale);
    const qualityText = saveQualitySelect.options[saveQualitySelect.selectedIndex].textContent;

    saveBtn.disabled = true;
    saveBtn.innerHTML = `‚è±Ô∏è Processing (${qualityText})...`;

    /*after save file name*/ const fileName = `All-in-one-minimize`;
    let wasControlsOpen = false;
    if (!controlsContainer.classList.contains('hidden')) {
        controlsContainer.classList.add('hidden');
        wasControlsOpen = true;
    }
    
    // Hide file name overlays before capture
    paperWrapper.classList.add('hide-overlays');

    // **CRITICAL OPTIMIZATION: REMOVED THE ASYNCHRONOUS PDF RE-RENDER LOOP**
    // The save process will now rely on the existing canvas content, making it FAST.


    try {
        if (saveType === 'doc' || saveType === 'docx') {
            const fileContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>${fileName}</title>
                    <meta name="viewport" content="width=device-width,initial-scale=1">
                    <style>
                        .paper {
                            width: ${currentOrientation === 'landscape' ? PAPER_SIZES[currentPaperSize].h : PAPER_SIZES[currentPaperSize].w}mm;
                            min-height: ${currentOrientation === 'landscape' ? PAPER_SIZES[currentPaperSize].w : PAPER_SIZES[currentPaperSize].h}mm;
                            margin: 0 auto 20px;
                            box-shadow: none;
                            border: 1px solid #ccc;
                            padding: 10mm;
                            box-sizing: border-box;
                            page-break-after: always;
                        }
                        .box { border: 1px solid #eee; min-height: 100px; padding: 5px; margin-bottom: 5px; }
                        .box canvas { display: none; }
                        .box img { max-width: 100%; height: auto; display: block; }
                        @page { margin: 1in; }
                    </style>
                </head>
                <body>
                    <h1>${fileName} - Saved as Editable HTML (${saveType.toUpperCase()})</h1>
                    <p>Note: This file was saved as HTML with the .${saveType} extension. Layout precision depends on the word processor's HTML rendering.</p>
                    ${paperWrapper.innerHTML}
                </body>
                </html>
            `;
            const blob = new Blob([fileContent], { type: "application/msword" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.${saveType}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert(`Sheets saved as ${saveType.toUpperCase()}.`);
            return;
        }

        if (saveType === 'png' || saveType === 'jpg') {
            saveBtn.innerHTML = `‚è±Ô∏è Capturing image...`;
            // Use CAPTURE_SCALE (2.5x, 4.0x, or 6.0x) for quality save
            const canvas = await html2canvas(paperWrapper, {
                scale: CAPTURE_SCALE, 
                allowTaint: true,
                useCORS: true,
                scrollX: 0,
                scrollY: 0,
                windowWidth: paperWrapper.scrollWidth,
                windowHeight: paperWrapper.scrollHeight
            });

            let downloadURL = null;
            let extension = '';

            if (saveType === 'png') {
                downloadURL = canvas.toDataURL('image/png');
                extension = 'png';
            } else if (saveType === 'jpg') {
                downloadURL = canvas.toDataURL('image/jpeg', 1.0);
                extension = 'jpg';
            }

            if (downloadURL) {
                const a = document.createElement('a');
                a.href = downloadURL;
                a.download = `${fileName}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                alert(`Sheets saved as ${extension.toUpperCase()} image.`);
            } else {
                alert('Failed to generate image.');
            }
            return;
        }

        if (saveType === 'pdf') {
            saveBtn.innerHTML = `‚è±Ô∏è Creating final PDF...`;
            const { jsPDF } = window.jspdf;

            const paperElements = document.querySelectorAll('#page-wrapper .paper:not(.hidden)');
            if (paperElements.length === 0) {
                alert('No sheets visible to save.');
                return;
            }

            let pdf = null;
            for (let idx = 0; idx < paperElements.length; idx++) {
                const paper = paperElements[idx];
                const rect = paper.getBoundingClientRect();
                
                saveBtn.innerHTML = `‚è±Ô∏è Processing Page ${idx + 1} of ${paperElements.length}...`;

                const canvas = await html2canvas(paper, {
                    scale: CAPTURE_SCALE,
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null,
                    width: Math.ceil(rect.width),
                    height: Math.ceil(rect.height),
                    windowWidth: document.documentElement.clientWidth,
                    windowHeight: document.documentElement.clientHeight,
                    scrollX: -window.scrollX - rect.left,
                    scrollY: -window.scrollY - rect.top
                });

                const imgData = canvas.toDataURL('image/jpeg', 1.0);

                const baseSize = PAPER_SIZES[currentPaperSize];
                let pdfWidthMM = baseSize.w;
                let pdfHeightMM = baseSize.h;
                let orientation = 'portrait';
                if (paper.classList.contains('landscape')) {
                    orientation = 'landscape';
                    pdfWidthMM = baseSize.h;
                    pdfHeightMM = baseSize.w;
                }

                if (!pdf) {
                    pdf = new jsPDF({
                        orientation: orientation,
                        unit: 'mm',
                        format: [pdfWidthMM, pdfHeightMM]
                    });
                    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidthMM, pdfHeightMM, undefined, 'FAST');
                } else {
                    pdf.addPage([pdfWidthMM, pdfHeightMM], orientation.toLowerCase());
                    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidthMM, pdfHeightMM, undefined, 'FAST');
                }
            }

            if (pdf) {
                pdf.save(`${fileName}.pdf`);
                alert(`Sheets successfully saved as multi-page PDF!`);
            } else {
                alert('Failed to create PDF.');
            }
            return;
        }
    } catch (err) {
        console.error("Error during file saving:", err);
        alert('An unexpected error occurred while saving. Check console for details.');
    } finally {
        // Show overlays again
        paperWrapper.classList.remove('hide-overlays');

        // Note: No need to call resetPaper to re-render, as we rely on the current screen render for speed.

        if (wasControlsOpen) controlsContainer.classList.remove('hidden');
        saveBtn.disabled = false;
        updateSaveButtonText();
    }
};

/* ---------- Misc helpers (kept as original) ---------- */
function toggleControls(){
  const panel = document.getElementById('controls-panel-container');
  panel.classList.toggle('hidden');
  const btn = document.getElementById('toggle-controls-btn');
  btn.innerHTML = panel.classList.contains('hidden') ? '&#9664;' : '&#10006;';
}
function togglePaper(){
  const allPages = document.querySelectorAll('.paper');
  allPages.forEach(p=>p.classList.toggle('hidden'));
  const button = document.getElementById('togglePaperBtn');
  if (allPages[0] && allPages[0].classList.contains('hidden')) button.textContent = 'Show Screen Paper';
  else button.textContent = 'Hide Screen Paper';
}
function toggleBackground(){
  document.body.classList.toggle('bg-image');
  document.body.classList.toggle('bg-gradient');
  document.getElementById('toggle-bg-btn').textContent = document.body.classList.contains('bg-image') ? 'üíß Show Gradient Background' : 'üåà Show Background Image';
}

function handleQualityChange(newScale) {
    CURRENT_RENDER_SCALE = parseFloat(newScale);
    resetPaper(); // Re-render all canvases with the new scale
}

function updateSaveButtonText() {
    const saveQualitySelect = document.getElementById('save-quality-select');
    const selectedQualityScale = saveQualitySelect.value;
    const optionText = saveQualitySelect.options[saveQualitySelect.selectedIndex].textContent;
    const match = optionText.match(/\((.*?)\)/); // Extract scale from text
    const displayScale = match ? match[1] : `${selectedQualityScale}x`;
    document.getElementById('save-sheets-btn').innerHTML = `üíæ Start Save(${displayScale})`;
}

function attachLiveListeners() {
    ['margin-top','margin-bottom','margin-left','margin-right'].forEach(id => document.getElementById(id)?.addEventListener('change', updateMargins));
    ['box-width','box-height'].forEach(id => document.getElementById(id)?.addEventListener('change', updateDivisionSize));
    ['row-gap-input','col-gap-input'].forEach(id => document.getElementById(id)?.addEventListener('change', updateGapSizes));
    document.getElementById('paper-size-select')?.addEventListener('change', e => handlePaperSizeChange(e.target.value));
    document.querySelectorAll('input[name="pageDivision"]').forEach(el => el.addEventListener('change', e => handleDivisionChange(e.target.value)));
    document.querySelectorAll('input[name="paperOrientation"]').forEach(el => el.addEventListener('change', e => handleOrientationChange(e.target.value)));
    document.getElementById('multi-upload-btn')?.addEventListener('click', () => document.getElementById('multi-file-input').click());
    document.getElementById('multi-file-input')?.addEventListener('change', e => handleMultiPhotoUpload(e.target.files));
    document.querySelectorAll('#upload-mode-controls input[type="radio"]').forEach(r => r.addEventListener('change', e => uploadMode = e.target.value));
    document.getElementById('toggle-controls-btn')?.addEventListener('click', toggleControls);
    document.getElementById('toggle-bg-btn')?.addEventListener('click', toggleBackground);
    document.getElementById('togglePaperBtn')?.addEventListener('click', togglePaper);
    
    // Quality selector listener
    document.getElementById('quality-select')?.addEventListener('change', e => handleQualityChange(e.target.value));
    document.getElementById('save-quality-select')?.addEventListener('change', updateSaveButtonText);
}

document.addEventListener('DOMContentLoaded', () => {
    attachLiveListeners();
    calculateConstrainedBoxSize();
    
    // Manually set box size inputs to reflect the calculated full-page size based on A4/portrait/1x1/0 margins
    document.getElementById('box-width').value = (PAPER_SIZES['a4'].w / DIVISION_LAYOUTS['1'].cols).toFixed(1);
    document.getElementById('box-height').value = (PAPER_SIZES['a4'].h / DIVISION_LAYOUTS['1'].rows).toFixed(1);
    
    // Update Add Page button text to reflect 1 Division
    document.getElementById('add-page-btn').textContent = `‚ûï Add Empty Page (${currentLayout.boxesPerPage} Divisions)`;

    // Set initial quality scales and update save button text
    CURRENT_RENDER_SCALE = SCREEN_MAX_QUALITY_SCALE; // Default for screen is 4.0x
    document.getElementById('quality-select').value = SCREEN_MAX_QUALITY_SCALE.toString();
    document.getElementById('save-quality-select').value = DEFAULT_QUALITY_SCALE.toString(); // Default for save is FAST 2.5x
    updateSaveButtonText();

    // Create two pages by default (keeps your existing behavior)
    createPage(0);
    createPage(1);
});
</script>
</body>
</html>

